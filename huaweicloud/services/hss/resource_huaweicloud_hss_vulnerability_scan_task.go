package hss

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/chnsz/golangsdk"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/common"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils"
)

var vulnerabilityScanTaskNonUpdatableParams = []string{
	"manual_scan_type",
	"batch_flag",
	"range_type",
	"agent_id_list",
	"urgent_vul_id_list",
	"enterprise_project_id",
}

// @API HSS POST /v5/{project_id}/vulnerability/scan-task
// @API HSS GET /v5/{project_id}/vulnerability/scan-tasks
func ResourceVulnerabilityScanTask() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceVulnerabilityScanTaskCreate,
		ReadContext:   resourceVulnerabilityScanTaskRead,
		UpdateContext: resourceVulnerabilityScanTaskUpdate,
		DeleteContext: resourceVulnerabilityScanTaskDelete,

		CustomizeDiff: config.FlexibleForceNew(vulnerabilityScanTaskNonUpdatableParams),

		Schema: map[string]*schema.Schema{
			"region": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
			"manual_scan_type": {
				Type:     schema.TypeList,
				Required: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"batch_flag": {
				Type:     schema.TypeBool,
				Required: true,
			},
			"range_type": {
				Type:     schema.TypeString,
				Required: true,
			},
			"agent_id_list": {
				Type:     schema.TypeList,
				Optional: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"urgent_vul_id_list": {
				Type:     schema.TypeList,
				Optional: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"enterprise_project_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"enable_force_new": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: validation.StringInSlice([]string{"true", "false"}, false),
				Description:  utils.SchemaDesc("", utils.SchemaDescInput{Internal: true}),
			},
			"scan_type": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"start_time": {
				Type:     schema.TypeInt,
				Computed: true,
			},
			"end_time": {
				Type:     schema.TypeInt,
				Computed: true,
			},
			"scan_vul_types": {
				Type:     schema.TypeList,
				Computed: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"status": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"scanning_host_num": {
				Type:     schema.TypeInt,
				Computed: true,
			},
			"success_host_num": {
				Type:     schema.TypeInt,
				Computed: true,
			},
			"failed_host_num": {
				Type:     schema.TypeInt,
				Computed: true,
			},
			"estimated_time": {
				Type:     schema.TypeInt,
				Computed: true,
			},
		},
	}
}

func buildVulnerabilityScanTaskQueryParams(epsId string) string {
	if epsId != "" {
		return fmt.Sprintf("?enterprise_project_id=%s", epsId)
	}

	return ""
}

func buildVulnerabilityScanTaskBodyParams(d *schema.ResourceData) map[string]interface{} {
	bodyParams := map[string]interface{}{
		"manual_scan_type":   utils.ExpandToStringList(d.Get("manual_scan_type").([]interface{})),
		"batch_flag":         d.Get("batch_flag"),
		"range_type":         d.Get("range_type"),
		"agent_id_list":      utils.ValueIgnoreEmpty(utils.ExpandToStringList(d.Get("agent_id_list").([]interface{}))),
		"urgent_vul_id_list": utils.ValueIgnoreEmpty(utils.ExpandToStringList(d.Get("urgent_vul_id_list").([]interface{}))),
	}

	return bodyParams
}

func resourceVulnerabilityScanTaskCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	var (
		cfg     = meta.(*config.Config)
		region  = cfg.GetRegion(d)
		epsId   = cfg.GetEnterpriseProjectID(d)
		httpUrl = "v5/{project_id}/vulnerability/scan-task"
	)

	client, err := cfg.NewServiceClient("hss", region)
	if err != nil {
		return diag.Errorf("error creating HSS client: %s", err)
	}

	createPath := client.Endpoint + httpUrl
	createPath = strings.ReplaceAll(createPath, "{project_id}", client.ProjectID)
	createPath += buildVulnerabilityScanTaskQueryParams(epsId)
	createOpt := golangsdk.RequestOpts{
		KeepResponseBody: true,
		JSONBody:         utils.RemoveNil(buildVulnerabilityScanTaskBodyParams(d)),
	}

	resp, err := client.Request("POST", createPath, &createOpt)
	if err != nil {
		return diag.Errorf("error creating vulnerability scan task: %s", err)
	}

	respBody, err := utils.FlattenResponse(resp)
	if err != nil {
		return diag.FromErr(err)
	}

	taskId := utils.PathSearch("task_id", respBody, "").(string)
	if taskId == "" {
		return diag.Errorf("unable to find task ID from API response")
	}

	d.SetId(taskId)

	return resourceVulnerabilityScanTaskRead(ctx, d, meta)
}

func GetVulnerabilityScanTask(client *golangsdk.ServiceClient, taskId, epsId string) (interface{}, error) {
	httpUrl := "v5/{project_id}/vulnerability/scan-tasks"
	getPath := client.Endpoint + httpUrl
	getPath = strings.ReplaceAll(getPath, "{project_id}", client.ProjectID)
	getPath = fmt.Sprintf("%s?task_id=%s", getPath, taskId)
	if epsId != "" {
		getPath = fmt.Sprintf("%s&enterprise_project_id=%s", getPath, epsId)
	}

	getOpt := golangsdk.RequestOpts{
		KeepResponseBody: true,
	}

	requestResp, err := client.Request("GET", getPath, &getOpt)
	if err != nil {
		return nil, fmt.Errorf("error retrieving vulnerability scan task: %s", err)
	}

	respBody, err := utils.FlattenResponse(requestResp)
	if err != nil {
		return nil, err
	}

	scanTask := utils.PathSearch("data_list|[0]", respBody, nil)
	if scanTask == nil {
		return nil, golangsdk.ErrDefault404{}
	}

	return scanTask, nil
}

func resourceVulnerabilityScanTaskRead(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	var (
		cfg    = meta.(*config.Config)
		region = cfg.GetRegion(d)
		epsId  = cfg.GetEnterpriseProjectID(d)
	)

	client, err := cfg.NewServiceClient("hss", region)
	if err != nil {
		return diag.Errorf("error creating HSS client: %s", err)
	}

	task, err := GetVulnerabilityScanTask(client, d.Id(), epsId)
	if err != nil {
		return common.CheckDeletedDiag(d, err, "error retrieving vulnerability scan task")
	}

	mErr := multierror.Append(nil,
		d.Set("region", region),
		d.Set("scan_type", utils.PathSearch("scan_type", task, nil)),
		d.Set("start_time", utils.PathSearch("start_time", task, nil)),
		d.Set("end_time", utils.PathSearch("end_time", task, nil)),
		d.Set("scan_vul_types", utils.PathSearch("scan_vul_types", task, nil)),
		d.Set("status", utils.PathSearch("status", task, nil)),
		d.Set("scanning_host_num", utils.PathSearch("scanning_host_num", task, nil)),
		d.Set("success_host_num", utils.PathSearch("success_host_num", task, nil)),
		d.Set("failed_host_num", utils.PathSearch("failed_host_num", task, nil)),
		d.Set("estimated_time", utils.PathSearch("estimated_time", task, nil)),
	)

	return diag.FromErr(mErr.ErrorOrNil())
}

func resourceVulnerabilityScanTaskUpdate(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics {
	// No processing is performed in the 'Update()' method because the resource is a one-time action resource.
	return nil
}

func resourceVulnerabilityScanTaskDelete(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics {
	// No processing is performed in the 'Delete()' method because the resource is a one-time action resource.
	return nil
}
