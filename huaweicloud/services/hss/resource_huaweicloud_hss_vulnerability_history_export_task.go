package hss

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/chnsz/golangsdk"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils"
)

// @API HSS POST /v5/{project_id}/vulnerability/history/export-task
// @API HSS GET /v5/{project_id}/export-task/{task_id}
func ResourceVulnerabilityHistoryExportTask() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceVulnerabilityHistoryExportTaskCreate,
		ReadContext:   resourceVulnerabilityHistoryExportTaskRead,
		UpdateContext: resourceVulnerabilityHistoryExportTaskUpdate,
		DeleteContext: resourceVulnerabilityHistoryExportTaskDelete,

		CustomizeDiff: config.FlexibleForceNew([]string{
			"export_headers",
			"enterprise_project_id",
			"vul_name",
			"repair_priority",
			"host_name",
			"host_ip",
			"is_affect_business",
			"status",
			"asset_value",
			"label",
			"type",
			"group_name",
			"handle_cycle",
			"specific_vuls",
			"specific_vuls.*.host_id",
			"specific_vuls.*.vul_id",
			"export_size",
		}),

		Schema: map[string]*schema.Schema{
			"region": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
			"export_headers": {
				Type:     schema.TypeList,
				Required: true,
				Elem: &schema.Schema{
					Type: schema.TypeList,
					Elem: &schema.Schema{Type: schema.TypeString},
				},
			},
			"enterprise_project_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"vul_name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"repair_priority": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"host_name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"host_ip": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"is_affect_business": {
				Type:     schema.TypeBool,
				Optional: true,
			},
			"status": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"asset_value": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"label": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"type": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"group_name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"handle_cycle": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"specific_vuls": {
				Type:     schema.TypeList,
				Optional: true,
				Elem:     historyExportSpecificVulsSchema(),
			},
			"export_size": {
				Type:     schema.TypeInt,
				Optional: true,
			},
			"enable_force_new": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: validation.StringInSlice([]string{"true", "false"}, false),
				Description:  utils.SchemaDesc("", utils.SchemaDescInput{Internal: true}),
			},
			"task_name": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"task_status": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"file_id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"file_name": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
	}
}

func historyExportSpecificVulsSchema() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"host_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"vul_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
		},
	}
}

func buildVulnerabilityHistoryExportTaskQueryParams(epsId string) string {
	if epsId != "" {
		return fmt.Sprintf("?enterprise_project_id=%v", epsId)
	}

	return ""
}

func buildCreateExportTaskSpecificVulsBodyParams(rawArray []interface{}) []map[string]interface{} {
	if len(rawArray) == 0 {
		return nil
	}

	rst := make([]map[string]interface{}, 0, len(rawArray))
	for _, v := range rawArray {
		rawMap, ok := v.(map[string]interface{})
		if !ok {
			continue
		}

		rst = append(rst, map[string]interface{}{
			"host_id": rawMap["host_id"],
			"vul_id":  rawMap["vul_id"],
		})
	}

	return rst
}

func buildVulnerabilityHistoryExportTaskBodyParams(d *schema.ResourceData) map[string]interface{} {
	return map[string]interface{}{
		"export_headers":     d.Get("export_headers"),
		"vul_name":           utils.ValueIgnoreEmpty(d.Get("vul_name")),
		"repair_priority":    utils.ValueIgnoreEmpty(d.Get("repair_priority")),
		"host_name":          utils.ValueIgnoreEmpty(d.Get("host_name")),
		"host_ip":            utils.ValueIgnoreEmpty(d.Get("host_ip")),
		"is_affect_business": d.Get("is_affect_business"),
		"status":             utils.ValueIgnoreEmpty(d.Get("status")),
		"asset_value":        utils.ValueIgnoreEmpty(d.Get("asset_value")),
		"label":              utils.ValueIgnoreEmpty(d.Get("label")),
		"type":               utils.ValueIgnoreEmpty(d.Get("type")),
		"group_name":         utils.ValueIgnoreEmpty(d.Get("group_name")),
		"handle_cycle":       utils.ValueIgnoreEmpty(d.Get("handle_cycle")),
		"specific_vuls":      buildCreateExportTaskSpecificVulsBodyParams(d.Get("specific_vuls").([]interface{})),
		"export_size":        utils.ValueIgnoreEmpty(d.Get("export_size")),
	}
}

func getExportTask(client *golangsdk.ServiceClient, taskId, epsID string) (interface{}, error) {
	requestPath := client.Endpoint + "v5/{project_id}/export-task/{task_id}"
	requestPath = strings.ReplaceAll(requestPath, "{project_id}", client.ProjectID)
	requestPath = strings.ReplaceAll(requestPath, "{task_id}", taskId)
	requestPath += buildVulnerabilityHistoryExportTaskQueryParams(epsID)
	requestOpt := golangsdk.RequestOpts{
		KeepResponseBody: true,
	}

	resp, err := client.Request("GET", requestPath, &requestOpt)
	if err != nil {
		return nil, err
	}

	return utils.FlattenResponse(resp)
}

func waitingForExportTaskFinished(ctx context.Context, client *golangsdk.ServiceClient, d *schema.ResourceData,
	timeout time.Duration, epsID string) (interface{}, error) {
	stateConf := &resource.StateChangeConf{
		Pending: []string{"PENDING"},
		Target:  []string{"COMPLETED"},
		Refresh: func() (interface{}, string, error) {
			respBody, err := getExportTask(client, d.Id(), epsID)
			if err != nil {
				return nil, "ERROR", err
			}

			taskStatus := utils.PathSearch("task_status", respBody, "").(string)
			if taskStatus == "" {
				return nil, "ERROR", errors.New("task_status is not found in list API response")
			}

			// When the state enters the final state, safely exit the training logic.
			if taskStatus == "success" || taskStatus == "failure" {
				return respBody, "COMPLETED", nil
			}

			return respBody, "PENDING", nil
		},
		Timeout:      timeout,
		Delay:        5 * time.Second,
		PollInterval: 5 * time.Second,
	}

	return stateConf.WaitForStateContext(ctx)
}

func resourceVulnerabilityHistoryExportTaskCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	var (
		cfg     = meta.(*config.Config)
		region  = cfg.GetRegion(d)
		product = "hss"
		epsId   = cfg.GetEnterpriseProjectID(d)
	)

	client, err := cfg.NewServiceClient(product, region)
	if err != nil {
		return diag.Errorf("error creating HSS client: %s", err)
	}

	requestPath := client.Endpoint + "v5/{project_id}/vulnerability/history/export-task"
	requestPath = strings.ReplaceAll(requestPath, "{project_id}", client.ProjectID)
	requestPath += buildVulnerabilityHistoryExportTaskQueryParams(epsId)
	requestOpt := golangsdk.RequestOpts{
		KeepResponseBody: true,
		JSONBody:         utils.RemoveNil(buildVulnerabilityHistoryExportTaskBodyParams(d)),
	}

	resp, err := client.Request("POST", requestPath, &requestOpt)
	if err != nil {
		return diag.Errorf("error creating HSS vulnerability export task: %s", err)
	}

	respBody, err := utils.FlattenResponse(resp)
	if err != nil {
		return diag.FromErr(err)
	}

	taskId := utils.PathSearch("task_id", respBody, "").(string)
	if taskId == "" {
		return diag.Errorf("unable to find task_id in response")
	}

	d.SetId(taskId)

	taskRespBody, err := waitingForExportTaskFinished(ctx, client, d, d.Timeout(schema.TimeoutCreate), epsId)
	if err != nil {
		return diag.Errorf("error waiting for HSS vulnerability export task %s complete: %s", taskId, err)
	}

	mErr := multierror.Append(
		d.Set("task_name", utils.PathSearch("task_name", taskRespBody, nil)),
		d.Set("task_status", utils.PathSearch("task_status", taskRespBody, nil)),
		d.Set("file_id", utils.PathSearch("file_id", taskRespBody, nil)),
		d.Set("file_name", utils.PathSearch("file_name", taskRespBody, nil)),
	)
	if err := mErr.ErrorOrNil(); err != nil {
		return diag.Errorf("error setting HSS vulnerability export task attributes: %s", err)
	}

	return resourceVulnerabilityHistoryExportTaskRead(ctx, d, meta)
}

func resourceVulnerabilityHistoryExportTaskRead(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics {
	// No processing is performed in the 'Read()' method because the resource is a one-time action resource.
	return nil
}

func resourceVulnerabilityHistoryExportTaskUpdate(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics {
	// No processing is performed in the 'Update()' method because the resource is a one-time action resource.
	return nil
}

func resourceVulnerabilityHistoryExportTaskDelete(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics {
	errorMsg := `This resource is a one-time action resource used to create HSS vulnerability export task. Deleting this resource
	will not clear the corresponding request record, but will only remove the resource information from the tf state
    file.`
	return diag.Diagnostics{
		diag.Diagnostic{
			Severity: diag.Warning,
			Summary:  errorMsg,
		},
	}
}
