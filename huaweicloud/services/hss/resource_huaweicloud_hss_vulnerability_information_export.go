package hss

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/chnsz/golangsdk"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils"
)

var vulnerabilityInformationExportNonUpdatableParams = []string{"export_size", "category", "type", "vul_id", "vul_name",
	"host_id", "repair_priority", "handle_status", "cve_id", "label_list", "status", "asset_value", "group_name",
	"export_headers", "vul_id_list", "host_id_list", "enterprise_project_id"}

// @API HSS POST /v5/{project_id}/vul/export
// @API HSS GET /v5/{project_id}/export-task/{task_id}
func ResourceVulnerabilityInformationExport() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceVulnerabilityInformationExportCreate,
		ReadContext:   resourceVulnerabilityInformationExportRead,
		UpdateContext: resourceVulnerabilityInformationExportUpdate,
		DeleteContext: resourceVulnerabilityInformationExportDelete,

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(3 * time.Minute),
		},

		CustomizeDiff: config.FlexibleForceNew(vulnerabilityInformationExportNonUpdatableParams),

		Schema: map[string]*schema.Schema{
			"region": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
			"export_size": {
				Type:     schema.TypeInt,
				Required: true,
			},
			"category": {
				Type:     schema.TypeString,
				Required: true,
			},
			// Consistent with the structure of the API.
			// Current, this parameter is optional in the API documentation and is required after confirmation with the
			// HSS service.
			"export_headers": {
				Type:     schema.TypeList,
				Required: true,
				Elem: &schema.Schema{
					Type: schema.TypeList,
					Elem: &schema.Schema{Type: schema.TypeString},
				},
			},
			"type": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"vul_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"vul_name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"host_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"repair_priority": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"handle_status": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"cve_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"label_list": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"status": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"asset_value": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"group_name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"vul_id_list": {
				Type:     schema.TypeList,
				Optional: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"host_id_list": {
				Type:     schema.TypeList,
				Optional: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"enterprise_project_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"enable_force_new": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: validation.StringInSlice([]string{"true", "false"}, false),
				Description:  utils.SchemaDesc("", utils.SchemaDescInput{Internal: true}),
			},
			"task_id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"task_name": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"task_status": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"file_id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"file_name": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
	}
}

func buildCreateVulnerabilityInformationExportQueryParams(d *schema.ResourceData, epsId string) string {
	queryParams := ""
	queryParams = fmt.Sprintf("%s?export_size=%v", queryParams, d.Get("export_size"))
	queryParams = fmt.Sprintf("%s&category=%v", queryParams, d.Get("category"))

	if v, ok := d.GetOk("type"); ok {
		queryParams = fmt.Sprintf("%s&type=%v", queryParams, v)
	}
	if v, ok := d.GetOk("vul_id"); ok {
		queryParams = fmt.Sprintf("%s&vul_id=%v", queryParams, v)
	}
	if v, ok := d.GetOk("vul_name"); ok {
		queryParams = fmt.Sprintf("%s&vul_name=%v", queryParams, v)
	}
	if v, ok := d.GetOk("host_id"); ok {
		queryParams = fmt.Sprintf("%s&host_id=%v", queryParams, v)
	}
	if v, ok := d.GetOk("repair_priority"); ok {
		queryParams = fmt.Sprintf("%s&repair_priority=%v", queryParams, v)
	}
	if v, ok := d.GetOk("handle_status"); ok {
		queryParams = fmt.Sprintf("%s&handle_status=%v", queryParams, v)
	}
	if v, ok := d.GetOk("cve_id"); ok {
		queryParams = fmt.Sprintf("%s&cve_id=%v", queryParams, v)
	}
	if v, ok := d.GetOk("label_list"); ok {
		queryParams = fmt.Sprintf("%s&label_list=%v", queryParams, v)
	}
	if v, ok := d.GetOk("status"); ok {
		queryParams = fmt.Sprintf("%s&status=%v", queryParams, v)
	}
	if v, ok := d.GetOk("asset_value"); ok {
		queryParams = fmt.Sprintf("%s&asset_value=%v", queryParams, v)
	}
	if v, ok := d.GetOk("group_name"); ok {
		queryParams = fmt.Sprintf("%s&group_name=%v", queryParams, v)
	}
	if epsId != "" {
		queryParams = fmt.Sprintf("%s&enterprise_project_id=%v", queryParams, epsId)
	}

	return queryParams
}

func buildCreateVulnerabilityInformationExportBodyParams(d *schema.ResourceData) map[string]interface{} {
	bodyParams := map[string]interface{}{
		"vul_id_list":  utils.ValueIgnoreEmpty(utils.ExpandToStringList(d.Get("vul_id_list").([]interface{}))),
		"host_id_list": utils.ValueIgnoreEmpty(utils.ExpandToStringList(d.Get("host_id_list").([]interface{}))),
	}

	exportHeadersInput := d.Get("export_headers").([]interface{})
	exportHeadersParams := make([]interface{}, 0, len(exportHeadersInput))
	for _, headerRaw := range exportHeadersInput {
		headerRow := utils.ExpandToStringList(headerRaw.([]interface{}))
		headerParams := make([]interface{}, len(headerRow))
		for i, v := range headerRow {
			headerParams[i] = v
		}
		exportHeadersParams = append(exportHeadersParams, headerParams)
	}
	bodyParams["export_headers"] = exportHeadersParams

	return bodyParams
}

func resourceVulnerabilityInformationExportCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	var (
		cfg     = meta.(*config.Config)
		region  = cfg.GetRegion(d)
		product = "hss"
		epsId   = cfg.GetEnterpriseProjectID(d)
	)

	client, err := cfg.NewServiceClient(product, region)
	if err != nil {
		return diag.Errorf("error creating HSS client: %s", err)
	}

	requestPath := client.Endpoint + "v5/{project_id}/vul/export"
	requestPath = strings.ReplaceAll(requestPath, "{project_id}", client.ProjectID)
	requestPath += buildCreateVulnerabilityInformationExportQueryParams(d, epsId)
	requestOpt := golangsdk.RequestOpts{
		KeepResponseBody: true,
		JSONBody:         utils.RemoveNil(buildCreateVulnerabilityInformationExportBodyParams(d)),
	}

	resp, err := client.Request("POST", requestPath, &requestOpt)
	if err != nil {
		return diag.Errorf("error exporting HSS vulnerability information: %s", err)
	}

	respBody, err := utils.FlattenResponse(resp)
	if err != nil {
		return diag.FromErr(err)
	}

	taskId := utils.PathSearch("task_id", respBody, "").(string)
	if taskId == "" {
		return diag.Errorf("error exporting HSS vulnerability information: task ID is not found in API response")
	}

	d.SetId(taskId)

	queryTaskRespBody, err := waitingForExportTaskSuccess(ctx, client, d.Timeout(schema.TimeoutCreate), taskId)
	if err != nil {
		return diag.Errorf("error waiting for the HSS vulnerability information export task to complete: %s", err)
	}

	mErr := multierror.Append(
		d.Set("region", region),
		d.Set("task_id", taskId),
		d.Set("task_name", utils.PathSearch("task_name", queryTaskRespBody, nil)),
		d.Set("task_status", utils.PathSearch("task_status", queryTaskRespBody, nil)),
		d.Set("file_id", utils.PathSearch("file_id", queryTaskRespBody, nil)),
		d.Set("file_name", utils.PathSearch("file_name", queryTaskRespBody, nil)),
	)

	return diag.FromErr(mErr.ErrorOrNil())
}

func queryExportTask(client *golangsdk.ServiceClient, taskId string) (interface{}, error) {
	requestPath := client.Endpoint + "v5/{project_id}/export-task/{task_id}"
	requestPath = strings.ReplaceAll(requestPath, "{project_id}", client.ProjectID)
	requestPath = strings.ReplaceAll(requestPath, "{task_id}", taskId)
	requestOpt := golangsdk.RequestOpts{
		KeepResponseBody: true,
	}

	resp, err := client.Request("GET", requestPath, &requestOpt)
	if err != nil {
		return nil, fmt.Errorf("error retrieving HSS vulnerability information export task: %s", err)
	}

	return utils.FlattenResponse(resp)
}

func waitingForExportTaskSuccess(ctx context.Context, client *golangsdk.ServiceClient, timeout time.Duration, taskId string) (interface{}, error) {
	stateConf := &resource.StateChangeConf{
		Pending: []string{"PENDING"},
		Target:  []string{"COMPLETED"},
		Refresh: func() (interface{}, string, error) {
			respBody, err := queryExportTask(client, taskId)
			if err != nil {
				return nil, "ERROR", err
			}

			taskStatus := utils.PathSearch("task_status", respBody, "").(string)
			if taskStatus == "" {
				return nil, "ERROR", errors.New("task_status is not found in API response")
			}

			if taskStatus == "success" {
				return respBody, "COMPLETED", nil
			}

			if taskStatus == "failure" {
				return respBody, "ERROR", fmt.Errorf("unexpected task status: %s", taskStatus)
			}

			return respBody, "PENDING", nil
		},
		Timeout:      timeout,
		Delay:        5 * time.Second,
		PollInterval: 5 * time.Second,
	}

	queryTaskRespBody, err := stateConf.WaitForStateContext(ctx)

	return queryTaskRespBody, err
}

func resourceVulnerabilityInformationExportRead(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics {
	// No processing is performed in the 'Read()' method because the resource is a one-time action resource.
	return nil
}

func resourceVulnerabilityInformationExportUpdate(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics {
	// No processing is performed in the 'Update()' method because the resource is a one-time action resource.
	return nil
}

func resourceVulnerabilityInformationExportDelete(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics {
	errorMsg := `This resource is a one-time action resource used to export HSS vulnerability information. Deleting
    this resource will not clear the corresponding exported record, but will only remove the resource information from
    the tf state file.`
	return diag.Diagnostics{
		diag.Diagnostic{
			Severity: diag.Warning,
			Summary:  errorMsg,
		},
	}
}
