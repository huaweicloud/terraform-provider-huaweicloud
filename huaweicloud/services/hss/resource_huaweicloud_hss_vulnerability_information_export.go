package hss

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"

	"github.com/chnsz/golangsdk"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils"
)

var vulnerabilityInformationExportNonUpdatableParams = []string{"export_size", "category", "type", "vul_id", "vul_name",
	"host_id", "repair_priority", "handle_status", "cve_id", "label_list", "status", "asset_value", "group_name",
	"export_headers", "vul_id_list", "host_id_list", "enterprise_project_id"}

// This resource is used to delete HSS isolated files.
// Due to the lack of test scenarios, this code is not tested and is not documented externally.
// Documentation is only stored in docs/incubating.

// @API HSS POST /v5/{project_id}/vul/export
func ResourceVulnerabilityInformationExport() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceVulnerabilityInformationExportCreate,
		ReadContext:   resourceVulnerabilityInformationExportRead,
		UpdateContext: resourceVulnerabilityInformationExportUpdate,
		DeleteContext: resourceVulnerabilityInformationExportDelete,

		CustomizeDiff: config.FlexibleForceNew(vulnerabilityInformationExportNonUpdatableParams),

		Schema: map[string]*schema.Schema{
			"region": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
			"export_size": {
				Type:     schema.TypeInt,
				Required: true,
			},
			"category": {
				Type:     schema.TypeString,
				Required: true,
			},
			"type": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"vul_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"vul_name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"host_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"repair_priority": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"handle_status": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"cve_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"label_list": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"status": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"asset_value": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"group_name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"export_headers": {
				Type:     schema.TypeList,
				Optional: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"vul_id_list": {
				Type:     schema.TypeList,
				Optional: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"host_id_list": {
				Type:     schema.TypeList,
				Optional: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},
			"enterprise_project_id": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"enable_force_new": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: validation.StringInSlice([]string{"true", "false"}, false),
				Description:  utils.SchemaDesc("", utils.SchemaDescInput{Internal: true}),
			},
			"task_id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"task_name": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"task_status": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"file_id": {
				Type:     schema.TypeString,
				Computed: true,
			},
			"file_name": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
	}
}

func buildCreateVulnerabilityInformationExportQueryParams(d *schema.ResourceData, epsId string) string {
	queryParams := ""
	queryParams = fmt.Sprintf("%s?export_size=%v", queryParams, d.Get("export_size"))
	queryParams = fmt.Sprintf("%s&category=%v", queryParams, d.Get("category"))

	if v, ok := d.GetOk("type"); ok {
		queryParams = fmt.Sprintf("%s&type=%v", queryParams, v)
	}
	if v, ok := d.GetOk("vul_id"); ok {
		queryParams = fmt.Sprintf("%s&vul_id=%v", queryParams, v)
	}
	if v, ok := d.GetOk("vul_name"); ok {
		queryParams = fmt.Sprintf("%s&vul_name=%v", queryParams, v)
	}
	if v, ok := d.GetOk("host_id"); ok {
		queryParams = fmt.Sprintf("%s&host_id=%v", queryParams, v)
	}
	if v, ok := d.GetOk("repair_priority"); ok {
		queryParams = fmt.Sprintf("%s&repair_priority=%v", queryParams, v)
	}
	if v, ok := d.GetOk("handle_status"); ok {
		queryParams = fmt.Sprintf("%s&handle_status=%v", queryParams, v)
	}
	if v, ok := d.GetOk("cve_id"); ok {
		queryParams = fmt.Sprintf("%s&cve_id=%v", queryParams, v)
	}
	if v, ok := d.GetOk("label_list"); ok {
		queryParams = fmt.Sprintf("%s&label_list=%v", queryParams, v)
	}
	if v, ok := d.GetOk("status"); ok {
		queryParams = fmt.Sprintf("%s&status=%v", queryParams, v)
	}
	if v, ok := d.GetOk("asset_value"); ok {
		queryParams = fmt.Sprintf("%s&asset_value=%v", queryParams, v)
	}
	if v, ok := d.GetOk("group_name"); ok {
		queryParams = fmt.Sprintf("%s&group_name=%v", queryParams, v)
	}
	if epsId != "" {
		queryParams = fmt.Sprintf("%s&enterprise_project_id=%v", queryParams, epsId)
	}

	return queryParams
}

func buildCreateVulnerabilityInformationExportBodyParams(d *schema.ResourceData) map[string]interface{} {
	bodyParams := map[string]interface{}{
		"export_headers": []interface{}{[]interface{}{}},
		"vul_id_list":    utils.ValueIgnoreEmpty(utils.ExpandToStringList(d.Get("vul_id_list").([]interface{}))),
		"host_id_list":   utils.ValueIgnoreEmpty(utils.ExpandToStringList(d.Get("host_id_list").([]interface{}))),
	}

	exportHeadersInput := d.Get("export_headers").([]interface{})
	if len(exportHeadersInput) > 0 {
		bodyParams["export_headers"] = []interface{}{utils.ExpandToStringList(exportHeadersInput)}
	}

	return bodyParams
}

func resourceVulnerabilityInformationExportCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	var (
		cfg     = meta.(*config.Config)
		region  = cfg.GetRegion(d)
		product = "hss"
		epsId   = cfg.GetEnterpriseProjectID(d)
	)

	client, err := cfg.NewServiceClient(product, region)
	if err != nil {
		return diag.Errorf("error creating HSS client: %s", err)
	}

	requestPath := client.Endpoint + "v5/{project_id}/vul/export"
	requestPath = strings.ReplaceAll(requestPath, "{project_id}", client.ProjectID)
	requestPath += buildCreateVulnerabilityInformationExportQueryParams(d, epsId)
	requestOpt := golangsdk.RequestOpts{
		KeepResponseBody: true,
		JSONBody:         utils.RemoveNil(buildCreateVulnerabilityInformationExportBodyParams(d)),
	}

	resp, err := client.Request("POST", requestPath, &requestOpt)
	if err != nil {
		return diag.Errorf("error exporting HSS vulnerability information: %s", err)
	}

	respBody, err := utils.FlattenResponse(resp)
	if err != nil {
		return diag.FromErr(err)
	}

	taskId := utils.PathSearch("task_id", respBody, "").(string)
	if taskId == "" {
		return diag.Errorf("error exporting HSS vulnerability information: task ID is not found in API response")
	}

	d.SetId(taskId)

	queryTaskRespBody, err := waitingForExportTaskSuccess(ctx, client, d.Timeout(schema.TimeoutCreate), taskId)
	if err != nil {
		return diag.Errorf("error waiting for the HSS vulnerability information export task to complete: %s", err)
	}

	mErr := multierror.Append(
		d.Set("task_id", taskId),
		d.Set("task_name", utils.PathSearch("task_name", queryTaskRespBody, nil)),
		d.Set("task_status", utils.PathSearch("task_status", queryTaskRespBody, nil)),
		d.Set("file_id", utils.PathSearch("file_id", queryTaskRespBody, nil)),
		d.Set("file_name", utils.PathSearch("file_name", queryTaskRespBody, nil)),
	)

	return diag.FromErr(mErr.ErrorOrNil())
}

func queryExportTask(client *golangsdk.ServiceClient, taskId string) (interface{}, error) {
	requestPath := client.Endpoint + "v5/{project_id}/export-task/{task_id}"
	requestPath = strings.ReplaceAll(requestPath, "{project_id}", client.ProjectID)
	requestPath = strings.ReplaceAll(requestPath, "{task_id}", taskId)
	requestOpt := golangsdk.RequestOpts{
		KeepResponseBody: true,
	}

	resp, err := client.Request("GET", requestPath, &requestOpt)
	if err != nil {
		return nil, fmt.Errorf("error retrieving HSS vulnerability information export task: %s", err)
	}

	return utils.FlattenResponse(resp)
}

func waitingForExportTaskSuccess(ctx context.Context, client *golangsdk.ServiceClient, timeout time.Duration, taskId string) (interface{}, error) {
	stateConf := &resource.StateChangeConf{
		Pending: []string{"PENDING"},
		Target:  []string{"COMPLETED"},
		Refresh: func() (interface{}, string, error) {
			respBody, err := queryExportTask(client, taskId)
			if err != nil {
				return nil, "ERROR", err
			}

			taskStatus := utils.PathSearch("task_status", respBody, "").(string)
			if taskStatus == "" {
				return nil, "ERROR", errors.New("task_status is not found in API response")
			}

			if taskStatus == "success" {
				return respBody, "COMPLETED", nil
			}

			if taskStatus == "failure" {
				return respBody, taskStatus, nil
			}

			return respBody, "PENDING", nil
		},
		Timeout:      timeout,
		Delay:        5 * time.Second,
		PollInterval: 5 * time.Second,
	}

	queryTaskRespBody, err := stateConf.WaitForStateContext(ctx)
	if err != nil {
		return nil, err
	}

	return queryTaskRespBody, nil
}

func resourceVulnerabilityInformationExportRead(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics {
	// No processing is performed in the 'Read()' method because the resource is a one-time action resource.
	return nil
}

func resourceVulnerabilityInformationExportUpdate(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics {
	// No processing is performed in the 'Update()' method because the resource is a one-time action resource.
	return nil
}

func resourceVulnerabilityInformationExportDelete(_ context.Context, _ *schema.ResourceData, _ interface{}) diag.Diagnostics {
	errorMsg := `This resource is a one-time action resource used to export HSS vulnerability information. Deleting
    this resource will not clear the corresponding exported record, but will only remove the resource information from
    the tf state file.`
	return diag.Diagnostics{
		diag.Diagnostic{
			Severity: diag.Warning,
			Summary:  errorMsg,
		},
	}
}
