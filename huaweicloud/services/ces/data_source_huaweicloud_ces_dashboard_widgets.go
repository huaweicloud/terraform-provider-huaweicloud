// Generated by PMS #314
package ces

import (
	"context"
	"strings"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/tidwall/gjson"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/httphelper"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/schemas"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils"
)

func DataSourceCesDashboardWidgets() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceCesDashboardWidgetsRead,

		Schema: map[string]*schema.Schema{
			"region": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: `Specifies the region in which to query the resource. If omitted, the provider-level region will be used.`,
			},
			"dashboard_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Specifies the dashboard ID.`,
			},
			"widgets": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The dashboard widget list.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"widget_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The dashboard widget ID.`,
						},
						"metric_display_mode": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `How many metrics will be displayed on one widget.`,
						},
						"properties": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The additional information.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"filter": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `How metric data is aggregated.`,
									},
									"top_n": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `The top n resources sorted by a metric.`,
									},
									"order": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `How top n resources by a metric are sorted on a widget.`,
									},
								},
							},
						},
						"view": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The graph type.`,
						},
						"title": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The dashboard widget title.`,
						},
						"threshold": {
							Type:        schema.TypeFloat,
							Computed:    true,
							Description: `The threshold of metrics on the graph.`,
						},
						"threshold_enabled": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether to display the threshold of metrics.`,
						},
						"location": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The dashboard widget coordinates.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"top": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `The grids between the widget and the top of the dashboard.`,
									},
									"left": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `The grids between the widget and the left side of the dashboard.`,
									},
									"width": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `The dashboard widget width.`,
									},
									"height": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `The dashboard widget height.`,
									},
								},
							},
						},
						"unit": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The metric unit.`,
						},
						"metrics": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The metric list.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"alias": {
										Type:        schema.TypeList,
										Computed:    true,
										Elem:        &schema.Schema{Type: schema.TypeString},
										Description: `The alias list of metrics on the dashboard widget.`,
									},
									"namespace": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The cloud service dimension.`,
									},
									"dimensions": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `The dimension list.`,
										Elem:        widgetsMetricsDimensionsElem(),
									},
									"metric_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The metric name.`,
									},
								},
							},
						},
						"created_at": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `When the dashboard widget was created.`,
						},
					},
				},
			},
		},
	}
}

// widgetsMetricsDimensionsElem
// The Elem of "widgets.metrics.dimensions"
func widgetsMetricsDimensionsElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"values": {
				Type:        schema.TypeList,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The dimension value list.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The dimension name.`,
			},
			"filter_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The resource type.`,
			},
		},
	}
}

type DashboardWidgetsDSWrapper struct {
	*schemas.ResourceDataWrapper
	Config *config.Config
}

func newDashboardWidgetsDSWrapper(d *schema.ResourceData, meta interface{}) *DashboardWidgetsDSWrapper {
	return &DashboardWidgetsDSWrapper{
		ResourceDataWrapper: schemas.NewSchemaWrapper(d),
		Config:              meta.(*config.Config),
	}
}

func dataSourceCesDashboardWidgetsRead(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	wrapper := newDashboardWidgetsDSWrapper(d, meta)
	lisDasWidRst, err := wrapper.ListDashboardWidgets()
	if err != nil {
		return diag.FromErr(err)
	}

	id, err := uuid.GenerateUUID()
	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(id)

	err = wrapper.listDashboardWidgetsToSchema(lisDasWidRst)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

// @API CES GET /v2/{project_id}/dashboards/{dashboard_id}/widgets
func (w *DashboardWidgetsDSWrapper) ListDashboardWidgets() (*gjson.Result, error) {
	client, err := w.NewClient(w.Config, "ces")
	if err != nil {
		return nil, err
	}

	uri := "/v2/{project_id}/dashboards/{dashboard_id}/widgets"
	uri = strings.ReplaceAll(uri, "{dashboard_id}", w.Get("dashboard_id").(string))
	return httphelper.New(client).
		Method("GET").
		URI(uri).
		Request().
		Result()
}

func (w *DashboardWidgetsDSWrapper) listDashboardWidgetsToSchema(body *gjson.Result) error {
	d := w.ResourceData
	mErr := multierror.Append(nil,
		d.Set("region", w.Config.GetRegion(w.ResourceData)),
		d.Set("widgets", schemas.SliceToList(body.Get("widgets"),
			func(widgets gjson.Result) any {
				return map[string]any{
					"widget_id":           widgets.Get("widget_id").Value(),
					"metric_display_mode": widgets.Get("metric_display_mode").Value(),
					"properties": schemas.SliceToList(widgets.Get("properties"),
						func(properties gjson.Result) any {
							return map[string]any{
								"filter": properties.Get("filter").Value(),
								"top_n":  properties.Get("topN").Value(),
								"order":  properties.Get("order").Value(),
							}
						},
					),
					"view":              widgets.Get("view").Value(),
					"title":             widgets.Get("title").Value(),
					"threshold":         widgets.Get("threshold").Value(),
					"threshold_enabled": widgets.Get("threshold_enabled").Value(),
					"location": schemas.SliceToList(widgets.Get("location"),
						func(location gjson.Result) any {
							return map[string]any{
								"top":    location.Get("top").Value(),
								"left":   location.Get("left").Value(),
								"width":  location.Get("width").Value(),
								"height": location.Get("height").Value(),
							}
						},
					),
					"unit": widgets.Get("unit").Value(),
					"metrics": schemas.SliceToList(widgets.Get("metrics"),
						func(metrics gjson.Result) any {
							return map[string]any{
								"alias":       schemas.SliceToStrList(metrics.Get("alias")),
								"namespace":   metrics.Get("namespace").Value(),
								"dimensions":  w.setWidMetDim(metrics),
								"metric_name": metrics.Get("metric_name").Value(),
							}
						},
					),
					"created_at": w.setWidgetsCreateTime(widgets),
				}
			},
		)),
	)
	return mErr.ErrorOrNil()
}

func (*DashboardWidgetsDSWrapper) setWidMetDim(metrics gjson.Result) any {
	return schemas.SliceToList(metrics.Get("dimensions"), func(dimensions gjson.Result) any {
		return map[string]any{
			"values":      schemas.SliceToStrList(dimensions.Get("values")),
			"name":        dimensions.Get("name").Value(),
			"filter_type": dimensions.Get("filter_type").Value(),
		}
	})
}

func (*DashboardWidgetsDSWrapper) setWidgetsCreateTime(data gjson.Result) string {
	return utils.FormatTimeStampRFC3339(int64(data.Get("create_time").Float()/1000), false)
}
