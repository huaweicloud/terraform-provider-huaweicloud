// Generated by PMS #619
package lts

import (
	"context"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/tidwall/gjson"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/filters"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/httphelper"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/schemas"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils"
)

func DataSourceHostAccesses() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceHostAccessesRead,

		Schema: map[string]*schema.Schema{
			"region": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"access_config_name_list": {
				Type:        schema.TypeList,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The list of the host access names.`,
			},
			"host_group_name_list": {
				Type:        schema.TypeList,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The list host of the group names associated with the host access.`,
			},
			"log_group_name_list": {
				Type:        schema.TypeList,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The list of log group names.`,
			},
			"log_stream_name_list": {
				Type:        schema.TypeList,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The list of log stream names.`,
			},
			"tags": {
				Type:        schema.TypeMap,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The key/value pairs to associate with the host access.`,
			},
			"accesses": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `All host accesses that match the filter parameters.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The ID of the host access.`,
						},
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The name of the host access.`,
						},
						"host_group_ids": {
							Type:        schema.TypeList,
							Computed:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: `The ID list of the log access host groups.`,
						},
						"log_group_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The ID of the log group to which the host access belongs.`,
						},
						"log_group_name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The name of the log group to which the host access belongs.`,
						},
						"log_stream_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The ID of the log stream to which the host access belongs.`,
						},
						"log_stream_name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The name of the log stream to which the host access belongs.`,
						},
						"access_config": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The configuration detail of the host access.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"paths": {
										Type:        schema.TypeList,
										Computed:    true,
										Elem:        &schema.Schema{Type: schema.TypeString},
										Description: `The list of paths where collected logs are located.`,
									},
									"black_paths": {
										Type:        schema.TypeList,
										Computed:    true,
										Elem:        &schema.Schema{Type: schema.TypeString},
										Description: `The collection path blacklist.`,
									},
									"single_log_format": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `The configuration single-line logs.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"mode": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The mode of single-line log format.`,
												},
												"value": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The value of single-line log format.`,
												},
											},
										},
									},
									"multi_log_format": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `The configuration multi-line logs.`,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"mode": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The mode of multi-line log format.`,
												},
												"value": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: `The value of multi-line log format.`,
												},
											},
										},
									},
									"windows_log_info": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `The configuration of Windows event logs.`,
										Elem:        accAccConWinLogInfoElem(),
									},
									"custom_key_value": {
										Type:        schema.TypeMap,
										Computed:    true,
										Elem:        &schema.Schema{Type: schema.TypeString},
										Description: `The custom key/value pairs of the host access.`,
									},
									"system_fields": {
										Type:        schema.TypeList,
										Computed:    true,
										Elem:        &schema.Schema{Type: schema.TypeString},
										Description: `The list of system built-in fields of the host access.`,
									},
									"repeat_collect": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Whether the file is allowed to be collected repeatedly.`,
									},
								},
							},
						},
						"access_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The type of the log access.`,
						},
						"tags": {
							Type:        schema.TypeMap,
							Computed:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: `The key/value pairs to associate with the host access.`,
						},
						"processor_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The type of the ICAgent structuring parsing.`,
						},
						"processors": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The list of the ICAgent structuring parsing rules.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The type of the parser.`,
									},
									"detail": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The configuration of the parser, in JSON format.`,
									},
								},
							},
						},
						"demo_log": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The example log of the ICAgent structuring parsing.`,
						},
						"demo_fields": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The list of the parsed fields of the example log.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The name of the parsed field.`,
									},
									"value": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The value of the parsed field.`,
									},
								},
							},
						},
						"binary_collect": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether to allow collection of binary log files.`,
						},
						"encoding_format": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The encoding format log file.`,
						},
						"incremental_collect": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether to collect logs incrementally.`,
						},
						"log_split": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether log splitting is enabled.`,
						},
						"created_at": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The creation time of the host access, in RFC3339 format.`,
						},
					},
				},
			},
		},
	}
}

// accAccConWinLogInfoElem
// The Elem of "accesses.access_config.windows_log_info"
func accAccConWinLogInfoElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"categorys": {
				Type:        schema.TypeList,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The types of Windows event logs to be collected.`,
			},
			"event_level": {
				Type:        schema.TypeList,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `The list of Windows event levels.`,
			},
			"time_offset": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The collection time offset unit.`,
			},
			"time_offset_unit": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The collection time offset.`,
			},
		},
	}
}

type HostAccessesDSWrapper struct {
	*schemas.ResourceDataWrapper
	Config *config.Config
}

func newHostAccessesDSWrapper(d *schema.ResourceData, meta interface{}) *HostAccessesDSWrapper {
	return &HostAccessesDSWrapper{
		ResourceDataWrapper: schemas.NewSchemaWrapper(d),
		Config:              meta.(*config.Config),
	}
}

func dataSourceHostAccessesRead(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	wrapper := newHostAccessesDSWrapper(d, meta)
	listAccessConfigRst, err := wrapper.ListAccessConfig()
	if err != nil {
		return diag.FromErr(err)
	}

	id, err := uuid.GenerateUUID()
	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(id)

	err = wrapper.listAccessConfigToSchema(listAccessConfigRst)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

// @API LTS POST /v3/{project_id}/lts/access-config-list
func (w *HostAccessesDSWrapper) ListAccessConfig() (*gjson.Result, error) {
	client, err := w.NewClient(w.Config, "lts")
	if err != nil {
		return nil, err
	}

	uri := "/v3/{project_id}/lts/access-config-list"
	params := map[string]any{
		"access_config_name_list": w.ListToArray("access_config_name_list"),
		"access_config_tag_list":  w.getAccessConfigTagList(),
		"host_group_name_list":    w.ListToArray("host_group_name_list"),
		"log_group_name_list":     w.ListToArray("log_group_name_list"),
		"log_stream_name_list":    w.ListToArray("log_stream_name_list"),
	}
	params = utils.RemoveNil(params)
	return httphelper.New(client).
		Method("POST").
		URI(uri).
		Body(params).
		Filter(
			filters.New().From("result").
				Where("access_config_type", "=", "AGENT"),
		).
		Request().
		Result()
}

func (w *HostAccessesDSWrapper) listAccessConfigToSchema(body *gjson.Result) error {
	d := w.ResourceData
	mErr := multierror.Append(nil,
		d.Set("region", w.Config.GetRegion(w.ResourceData)),
		d.Set("accesses", schemas.SliceToList(body.Get("result"),
			func(accesses gjson.Result) any {
				return map[string]any{
					"host_group_ids":  schemas.SliceToStrList(accesses.Get("host_group_info.host_group_id_list")),
					"log_group_id":    accesses.Get("log_info.log_group_id").Value(),
					"log_group_name":  accesses.Get("log_info.log_group_name").Value(),
					"log_stream_id":   accesses.Get("log_info.log_stream_id").Value(),
					"log_stream_name": accesses.Get("log_info.log_stream_name").Value(),
					"id":              accesses.Get("access_config_id").Value(),
					"name":            accesses.Get("access_config_name").Value(),
					"access_config": schemas.SliceToList(accesses.Get("access_config_detail"),
						func(accessConfig gjson.Result) any {
							return map[string]any{
								"single_log_format": schemas.SliceToList(accessConfig.Get("format.single"),
									func(singleLogFormat gjson.Result) any {
										return map[string]any{
											"mode":  singleLogFormat.Get("mode").Value(),
											"value": singleLogFormat.Get("value").Value(),
										}
									},
								),
								"multi_log_format": schemas.SliceToList(accessConfig.Get("format.multi"),
									func(multiLogFormat gjson.Result) any {
										return map[string]any{
											"mode":  multiLogFormat.Get("mode").Value(),
											"value": multiLogFormat.Get("value").Value(),
										}
									},
								),
								"paths":            schemas.SliceToStrList(accessConfig.Get("paths")),
								"black_paths":      schemas.SliceToStrList(accessConfig.Get("black_paths")),
								"windows_log_info": w.setRacdwli(accessConfig),
								"custom_key_value": accessConfig.Get("custom_key_value").Value(),
								"system_fields":    schemas.SliceToStrList(accessConfig.Get("system_fields")),
								"repeat_collect":   accessConfig.Get("repeat_collect").Value(),
							}
						},
					),
					"access_type":    accesses.Get("access_config_type").Value(),
					"tags":           w.setResAccConTag(accesses),
					"processor_type": accesses.Get("processor_type").Value(),
					"processors": schemas.SliceToList(accesses.Get("processors"),
						func(processors gjson.Result) any {
							return map[string]any{
								"type":   processors.Get("type").Value(),
								"detail": w.setResProDetail(processors),
							}
						},
					),
					"demo_log": accesses.Get("demo_log").Value(),
					"demo_fields": schemas.SliceToList(accesses.Get("demo_fields"),
						func(demoFields gjson.Result) any {
							return map[string]any{
								"name":  demoFields.Get("field_name").Value(),
								"value": demoFields.Get("field_value").Value(),
							}
						},
					),
					"binary_collect":      accesses.Get("binary_collect").Value(),
					"encoding_format":     accesses.Get("encoding_format").Value(),
					"incremental_collect": accesses.Get("incremental_collect").Value(),
					"log_split":           accesses.Get("log_split").Value(),
					"created_at":          w.setResultCreateTime(accesses),
				}
			},
		)),
	)
	return mErr.ErrorOrNil()
}

func (w *HostAccessesDSWrapper) getAccessConfigTagList() any {
	tags := w.Get("tags")
	if tags == nil {
		return nil
	}
	return utils.ExpandResourceTags(tags.(map[string]interface{}))
}

func (*HostAccessesDSWrapper) setRacdwli(accessConfig gjson.Result) any {
	return schemas.SliceToList(accessConfig.Get("windows_log_info"), func(windowsLogInfo gjson.Result) any {
		return map[string]any{
			"time_offset":      windowsLogInfo.Get("time_offset.offset").Value(),
			"time_offset_unit": windowsLogInfo.Get("time_offset.unit").Value(),
			"categorys":        schemas.SliceToStrList(windowsLogInfo.Get("categorys")),
			"event_level":      schemas.SliceToStrList(windowsLogInfo.Get("event_level")),
		}
	})
}

func (*HostAccessesDSWrapper) setResAccConTag(data gjson.Result) map[string]interface{} {
	tags := data.Get("access_config_tag").Value()
	return utils.FlattenTagsToMap(tags)
}

func (*HostAccessesDSWrapper) setResProDetail(data gjson.Result) string {
	return utils.JsonToString(data.Get("detail").Value())
}

func (*HostAccessesDSWrapper) setResultCreateTime(data gjson.Result) string {
	return utils.FormatTimeStampRFC3339(data.Get("create_time").Int()/1000, false)
}
