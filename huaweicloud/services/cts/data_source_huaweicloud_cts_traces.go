// Generated by PMS #173
package cts

import (
	"context"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/tidwall/gjson"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/httphelper"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/schemas"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils"
)

func DataSourceCtsTraces() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceCtsTracesRead,

		Schema: map[string]*schema.Schema{
			"region": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: `Specifies the region in which to query the resource. If omitted, the provider-level region will be used.`,
			},
			"trace_type": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Specifies the trace type.`,
			},
			"from": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Specifies the start time.`,
			},
			"to": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Specifies the end time.`,
			},
			"tracker_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the tracker name.`,
			},
			"service_type": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the cloud service type.`,
			},
			"user": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the user name.`,
			},
			"resource_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the cloud resource ID.`,
			},
			"resource_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the name of a resource.`,
			},
			"resource_type": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the type of a resource.`,
			},
			"trace_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the trace ID.`,
			},
			"trace_name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the trace name.`,
			},
			"trace_rating": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the trace status.`,
			},
			"traces": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The list of traces.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"api_version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The version of the API called in the trace.`,
						},
						"time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The time when a trace was generated.`,
						},
						"user": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The information of the user who performed the operation that triggered the trace.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The account ID.`,
									},
									"name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The account name.`,
									},
									"domain": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `The domain information of the user who performed the operation that triggered the trace.`,
										Elem:        tracesUserDomainElem(),
									},
								},
							},
						},
						"resource_name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The name of the resource on which the recorded operation was performed.`,
						},
						"endpoint": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The endpoint in the details page URL of the cloud resource on which the recorded operation was performed.`,
						},
						"trace_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The trace type.`,
						},
						"record_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The time when a trace was recorded by CTS.`,
						},
						"trace_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The Trace ID.`,
						},
						"resource_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The type of the resource on which the recorded operation was performed.`,
						},
						"source_ip": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The IP address of the tenant who performed the operation that triggered the trace.`,
						},
						"resource_url": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The details page URL (excluding the endpoint) of the cloud resource.`,
						},
						"request": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The request body of the recorded operation.`,
						},
						"request_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The ID of the request of the recorded operation.`,
						},
						"resource_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The ID of the cloud resource on which the recorded operation was performed.`,
						},
						"trace_rating": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The trace status.`,
						},
						"response": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The response body of the recorded operation.`,
						},
						"code": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The returned HTTP status code of the recorded operation.`,
						},
						"message": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The remarks added by other cloud services to the trace.`,
						},
						"service_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The cloud service on which the recorded operation was performed.`,
						},
						"location_info": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The information required for fault locating after a request error occurred.`,
						},
						"trace_name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The trace name.`,
						},
						"read_only": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether a user request is read-only.`,
						},
						"operation_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The operation ID of the trace`,
						},
					},
				},
			},
		},
	}
}

// tracesUserDomainElem
// The Elem of "traces.user.domain"
func tracesUserDomainElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The account ID.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The account name.`,
			},
		},
	}
}

type TracesDSWrapper struct {
	*schemas.ResourceDataWrapper
	Config *config.Config
}

func newTracesDSWrapper(d *schema.ResourceData, meta interface{}) *TracesDSWrapper {
	return &TracesDSWrapper{
		ResourceDataWrapper: schemas.NewSchemaWrapper(d),
		Config:              meta.(*config.Config),
	}
}

func dataSourceCtsTracesRead(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	wrapper := newTracesDSWrapper(d, meta)
	listTracesRst, err := wrapper.ListTraces()
	if err != nil {
		return diag.FromErr(err)
	}

	id, err := uuid.GenerateUUID()
	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(id)

	err = wrapper.listTracesToSchema(listTracesRst)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

// @API CTS GET /v3/{project_id}/traces
func (w *TracesDSWrapper) ListTraces() (*gjson.Result, error) {
	client, err := w.NewClient(w.Config, "cts")
	if err != nil {
		return nil, err
	}

	fromStr := w.Get("from")
	toStr := w.Get("to")
	from, err := utils.FormatUTCTimeStamp(fromStr.(string))
	if err != nil {
		return nil, err
	}
	to, err := utils.FormatUTCTimeStamp(toStr.(string))
	if err != nil {
		return nil, err
	}

	uri := "/v3/{project_id}/traces"
	params := map[string]any{
		"trace_type":    w.Get("trace_type"),
		"from":          from * 1000,
		"to":            to * 1000,
		"tracker_name":  w.Get("tracker_name"),
		"service_type":  w.Get("service_type"),
		"user":          w.Get("user"),
		"resource_id":   w.Get("resource_id"),
		"resource_name": w.Get("resource_name"),
		"resource_type": w.Get("resource_type"),
		"trace_id":      w.Get("trace_id"),
		"trace_name":    w.Get("trace_name"),
		"trace_rating":  w.Get("trace_rating"),
	}
	params = utils.RemoveNil(params)
	return httphelper.New(client).
		Method("GET").
		URI(uri).
		Query(params).
		MarkerPager("traces", "meta_data.marker", "next").
		OkCode(200).
		Request().
		Result()
}

func (w *TracesDSWrapper) listTracesToSchema(body *gjson.Result) error {
	d := w.ResourceData
	mErr := multierror.Append(nil,
		d.Set("region", w.Config.GetRegion(w.ResourceData)),
		d.Set("traces", schemas.SliceToList(body.Get("traces"),
			func(traces gjson.Result) any {
				return map[string]any{
					"api_version": traces.Get("api_version").Value(),
					"time":        w.setTracesTime(traces),
					"user": schemas.SliceToList(traces.Get("user"),
						func(user gjson.Result) any {
							return map[string]any{
								"id":     user.Get("id").Value(),
								"name":   user.Get("name").Value(),
								"domain": w.setTraUseDom(user),
							}
						},
					),
					"resource_name": traces.Get("resource_name").Value(),
					"endpoint":      traces.Get("endpoint").Value(),
					"trace_type":    traces.Get("trace_type").Value(),
					"record_time":   w.setTraRecTim(traces),
					"trace_id":      traces.Get("trace_id").Value(),
					"resource_type": traces.Get("resource_type").Value(),
					"source_ip":     traces.Get("source_ip").Value(),
					"resource_url":  traces.Get("resource_url").Value(),
					"request":       traces.Get("request").Value(),
					"request_id":    traces.Get("request_id").Value(),
					"resource_id":   traces.Get("resource_id").Value(),
					"trace_rating":  traces.Get("trace_rating").Value(),
					"response":      traces.Get("response").Value(),
					"code":          traces.Get("code").Value(),
					"message":       traces.Get("message").Value(),
					"service_type":  traces.Get("service_type").Value(),
					"location_info": traces.Get("location_info").Value(),
					"trace_name":    traces.Get("trace_name").Value(),
					"read_only":     traces.Get("read_only").Value(),
					"operation_id":  traces.Get("operation_id").Value(),
				}
			},
		)),
	)
	return mErr.ErrorOrNil()
}

func (*TracesDSWrapper) setTracesTime(data gjson.Result) string {
	return utils.FormatTimeStampUTC(int64(data.Get("time").Float() / 1000))
}

func (*TracesDSWrapper) setTraUseDom(user gjson.Result) any {
	return schemas.SliceToList(user.Get("domain"), func(domain gjson.Result) any {
		return map[string]any{
			"id":   domain.Get("id").Value(),
			"name": domain.Get("name").Value(),
		}
	})
}

func (*TracesDSWrapper) setTraRecTim(data gjson.Result) string {
	return utils.FormatTimeStampUTC(int64(data.Get("record_time").Float() / 1000))
}
