// Generated by PMS #600
package vpc

import (
	"context"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/tidwall/gjson"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/httphelper"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/schemas"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils"
)

func DataSourceVpcNetworkInterfaces() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceVpcNetworkInterfacesRead,

		Schema: map[string]*schema.Schema{
			"region": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: `Specifies the region in which to query the resource. If omitted, the provider-level region will be used.`,
			},
			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the name of the interface.`,
			},
			"interface_id": {
				Type:        schema.TypeList,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `Specifies the ID of the interface.`,
			},
			"network_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the network ID of the interface.`,
			},
			"mac_address": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the MAC address of the interface.`,
			},
			"device_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the device ID of the interface.`,
			},
			"device_owner": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the device owner of the interface.`,
			},
			"status": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the status of the interface.`,
			},
			"security_groups": {
				Type:        schema.TypeList,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `Specifies the security group IDs of the interface.`,
			},
			"fixed_ips": {
				Type:        schema.TypeList,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `Filter by fixed_ips=ip_address or fixed_ips=subnet_id.`,
			},
			"enterprise_project_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Default:     "all_granted_eps",
				Description: `Specifies the enterprise_project ID of the interface.`,
			},
			"enable_efi": {
				Type:        schema.TypeBool,
				Optional:    true,
				Description: `Specifies whether EFI is enabled .`,
			},
			"ports": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The list of interfaces.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"fixed_ips": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The interface IP addresses.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ip_address": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The interface IP address.`,
									},
									"subnet_id": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The ID of subnet to which the interface belongs.`,
									},
								},
							},
						},
						"security_groups": {
							Type:        schema.TypeList,
							Computed:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: `The interface security group IDs.`,
						},
						"mac_address": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The MAC address of the interface.`,
						},
						"status": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The interface status.`,
						},
						"allowed_address_pairs": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The IP address and MAC address pairs of the interface.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"ip_address": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The IP address.`,
									},
									"mac_address": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The MAC address.`,
									},
								},
							},
						},
						"instance_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The ID of the instance to which the interface belongs.`,
						},
						"zone_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The AZ that the interface belongs to.`,
						},
						"binding_vnic_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The type of the bound vNIC.`,
						},
						"binding_profile": {
							Type:        schema.TypeMap,
							Computed:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: `The user-defined settings.`,
						},
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The interface name.`,
						},
						"network_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The ID of the network that the interface belongs to.`,
						},
						"device_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The ID of the device that the interface belongs to.`,
						},
						"device_owner": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The device owner.`,
						},
						"extra_dhcp_opts": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The extended DHCP option.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"opt_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The option name.`,
									},
									"opt_value": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The option value.`,
									},
								},
							},
						},
						"port_security_enabled": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether the security option is enabled for the interface.`,
						},
						"ipv6_bandwidth_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The ID of the shared bandwidth bound to the IPv6 NIC.`,
						},
						"id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The interface ID`,
						},
						"dns_assignment": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The default private network domain name information of the primary NIC.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"hostname": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The interface host name.`,
									},
									"ip_address": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The interface IP address.`,
									},
									"fqdn": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The private network fully qualified domain name (FQDN) of the interface.`,
									},
								},
							},
						},
						"dns_name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The default private network DNS name of the primary NIC.`,
						},
						"binding_vif_details": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The VIF details.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"primary_interface": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Whether this is the primary NIC.`,
									},
									"port_filter": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `The port filter.`,
									},
									"ovs_hybrid_plug": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `The ovs hybrid plug.`,
									},
								},
							},
						},
						"instance_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The type of the instance to which the interface belongs.`,
						},
						"enable_efi": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether to enable EFI.`,
						},
					},
				},
			},
		},
	}
}

type NetworkInterfacesDSWrapper struct {
	*schemas.ResourceDataWrapper
	Config *config.Config
}

func newNetworkInterfacesDSWrapper(d *schema.ResourceData, meta interface{}) *NetworkInterfacesDSWrapper {
	return &NetworkInterfacesDSWrapper{
		ResourceDataWrapper: schemas.NewSchemaWrapper(d),
		Config:              meta.(*config.Config),
	}
}

func dataSourceVpcNetworkInterfacesRead(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	wrapper := newNetworkInterfacesDSWrapper(d, meta)
	listPortsRst, err := wrapper.ListPorts()
	if err != nil {
		return diag.FromErr(err)
	}

	id, err := uuid.GenerateUUID()
	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(id)

	err = wrapper.listPortsToSchema(listPortsRst)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

// @API VPC GET /v1/{project_id}/ports
func (w *NetworkInterfacesDSWrapper) ListPorts() (*gjson.Result, error) {
	client, err := w.NewClient(w.Config, "vpc")
	if err != nil {
		return nil, err
	}

	uri := "/v1/{project_id}/ports"
	params := map[string]any{
		"name":                  w.Get("name"),
		"id":                    w.ListToArray("interface_id"),
		"network_id":            w.Get("network_id"),
		"mac_address":           w.Get("mac_address"),
		"device_id":             w.Get("device_id"),
		"device_owner":          w.Get("device_owner"),
		"status":                w.Get("status"),
		"security_groups":       w.ListToArray("security_groups"),
		"fixed_ips":             w.ListToArray("fixed_ips"),
		"enterprise_project_id": w.Get("enterprise_project_id"),
		"enable_efi":            w.Get("enable_efi"),
	}
	params = utils.RemoveNil(params)
	return httphelper.New(client).
		Method("GET").
		URI(uri).
		Query(params).
		MarkerPager("ports", "ports.id", "marker").
		Request().
		Result()
}

func (w *NetworkInterfacesDSWrapper) listPortsToSchema(body *gjson.Result) error {
	d := w.ResourceData
	mErr := multierror.Append(nil,
		d.Set("region", w.Config.GetRegion(w.ResourceData)),
		d.Set("ports", schemas.SliceToList(body.Get("ports"),
			func(ports gjson.Result) any {
				return map[string]any{
					"fixed_ips": schemas.SliceToList(ports.Get("fixed_ips"),
						func(fixedIps gjson.Result) any {
							return map[string]any{
								"ip_address": fixedIps.Get("ip_address").Value(),
								"subnet_id":  fixedIps.Get("subnet_id").Value(),
							}
						},
					),
					"security_groups": schemas.SliceToStrList(ports.Get("security_groups")),
					"mac_address":     ports.Get("mac_address").Value(),
					"status":          ports.Get("status").Value(),
					"allowed_address_pairs": schemas.SliceToList(ports.Get("allowed_address_pairs"),
						func(allowedAddressPairs gjson.Result) any {
							return map[string]any{
								"ip_address":  allowedAddressPairs.Get("ip_address").Value(),
								"mac_address": allowedAddressPairs.Get("mac_address").Value(),
							}
						},
					),
					"instance_id":       ports.Get("instance_id").Value(),
					"zone_id":           ports.Get("zone_id").Value(),
					"binding_vnic_type": ports.Get("binding:vnic_type").Value(),
					"binding_profile":   schemas.MapToStrMap(ports.Get("binding:profile")),
					"name":              ports.Get("name").Value(),
					"network_id":        ports.Get("network_id").Value(),
					"device_id":         ports.Get("device_id").Value(),
					"device_owner":      ports.Get("device_owner").Value(),
					"extra_dhcp_opts": schemas.SliceToList(ports.Get("extra_dhcp_opts"),
						func(extraDhcpOpts gjson.Result) any {
							return map[string]any{
								"opt_name":  extraDhcpOpts.Get("opt_name").Value(),
								"opt_value": extraDhcpOpts.Get("opt_value").Value(),
							}
						},
					),
					"port_security_enabled": ports.Get("port_security_enabled").Value(),
					"ipv6_bandwidth_id":     ports.Get("ipv6_bandwidth_id").Value(),
					"id":                    ports.Get("id").Value(),
					"dns_assignment": schemas.SliceToList(ports.Get("dns_assignment"),
						func(dnsAssignment gjson.Result) any {
							return map[string]any{
								"hostname":   dnsAssignment.Get("hostname").Value(),
								"ip_address": dnsAssignment.Get("ip_address").Value(),
								"fqdn":       dnsAssignment.Get("fqdn").Value(),
							}
						},
					),
					"dns_name": ports.Get("dns_name").Value(),
					"binding_vif_details": schemas.SliceToList(ports.Get("binding:vif_details"),
						func(bindingVifDetails gjson.Result) any {
							return map[string]any{
								"primary_interface": bindingVifDetails.Get("primary_interface").Value(),
								"port_filter":       bindingVifDetails.Get("port_filter").Value(),
								"ovs_hybrid_plug":   bindingVifDetails.Get("ovs_hybrid_plug").Value(),
							}
						},
					),
					"instance_type": ports.Get("instance_type").Value(),
					"enable_efi":    ports.Get("enable_efi").Value(),
				}
			},
		)),
	)
	return mErr.ErrorOrNil()
}
