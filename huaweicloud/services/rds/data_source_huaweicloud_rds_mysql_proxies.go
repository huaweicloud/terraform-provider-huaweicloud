// Generated by PMS #442
package rds

import (
	"context"
	"strings"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/tidwall/gjson"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/httphelper"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/schemas"
)

func DataSourceRdsMysqlProxies() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceRdsMysqlProxiesRead,

		Schema: map[string]*schema.Schema{
			"region": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: `Specifies the region in which to query the resource. If omitted, the provider-level region will be used.`,
			},
			"instance_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Specifies the ID of RDS MySQL instance.`,
			},
			"proxy_list": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Indicates the proxy information list of a RDS MySQL instance.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"proxy": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Indicates the proxy information.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the proxy ID.`,
									},
									"name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the proxy name.`,
									},
									"node_num": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Indicates the number of proxy nodes.`,
									},
									"flavor_info": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Indicates the proxy specifications.`,
										Elem:        proxyListProxyFlavorInfoElem(),
									},
									"proxy_mode": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the Proxy read/write Mode.`,
									},
									"subnet_id": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the ID of the subnet to which the database proxy belongs.`,
									},
									"route_mode": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Indicates the routing policy of the proxy.`,
									},
									"status": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the status of the proxy.`,
									},
									"address": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the proxy address.`,
									},
									"port": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Indicates the port number.`,
									},
									"delay_threshold_in_seconds": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Indicates the delay threshold, in seconds.`,
									},
									"vcpus": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the CPU size of the proxy.`,
									},
									"memory": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the memory size of the proxy.`,
									},
									"nodes": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `Indicates the list of proxy nodes.`,
										Elem:        proxyListProxyNodesElem(),
									},
									"mode": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the cluster mode of the proxy.`,
									},
									"transaction_split": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the status of the proxy transaction splitting switch.`,
									},
									"connection_pool_type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the connection pool type.`,
									},
									"pay_mode": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the charging mode of the proxy.`,
									},
									"dns_name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the private domain name for the read/write splitting address of the proxy.`,
									},
									"seconds_level_monitor_fun_status": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the second-level monitoring status of the proxy.`,
									},
									"alt_flag": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates the ALT switch status.`,
									},
									"force_read_only": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates whether to forcibly read the route to the read-only mode.`,
									},
									"ssl_option": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates the SSL switch status.`,
									},
									"support_balance_route_mode": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates whether the proxy supports the load balancing routing mode.`,
									},
									"support_proxy_ssl": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates whether the database proxy supports the SSL function.`,
									},
									"support_switch_connection_pool_type": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates whether the proxy supports the switchover of the session`,
									},
									"support_transaction_split": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates whether the proxy supports transaction splitting.`,
									},
								},
							},
						},
						"master_instance": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Indicates the master instance information.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the instance ID.`,
									},
									"weight": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Indicates the read weight of a the instance.`,
									},
								},
							},
						},
						"readonly_instances": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Indicates the read-only instance information.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the instance ID.`,
									},
									"weight": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: `Indicates the read weight of the instance.`,
									},
								},
							},
						},
						"proxy_security_group_check_result": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Indicates whether the security group allows access from the database proxy`,
						},
					},
				},
			},
			"max_proxy_num": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `Indicates the maximum number of database proxies that can be enabled at the same time.`,
			},
			"max_proxy_node_num": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `Indicates the maximum number of proxy nodes that can be selected for a database proxy.`,
			},
			"support_balance_route_mode_for_favored_version": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `Indicates whether the load balancing routing mode can be set when`,
			},
		},
	}
}

// proxyListProxyFlavorInfoElem
// The Elem of "proxy_list.proxy.flavor_info"
func proxyListProxyFlavorInfoElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"group_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Indicates the flavor group type.`,
			},
			"code": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Indicates the specification code.`,
			},
		},
	}
}

// proxyListProxyNodesElem
// The Elem of "proxy_list.proxy.nodes"
func proxyListProxyNodesElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Indicates the proxy node ID.`,
			},
			"status": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Indicates the status of the proxy node.`,
			},
			"role": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Indicates the role of the proxy node:`,
			},
			"az_code": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Indicates the AZ where the proxy node is located.`,
			},
			"frozen_flag": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `Indicates whether the proxy node is frozen.`,
			},
		},
	}
}

type MysqlProxiesDSWrapper struct {
	*schemas.ResourceDataWrapper
	Config *config.Config
}

func newMysqlProxiesDSWrapper(d *schema.ResourceData, meta interface{}) *MysqlProxiesDSWrapper {
	return &MysqlProxiesDSWrapper{
		ResourceDataWrapper: schemas.NewSchemaWrapper(d),
		Config:              meta.(*config.Config),
	}
}

func dataSourceRdsMysqlProxiesRead(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	wrapper := newMysqlProxiesDSWrapper(d, meta)
	lisRdSfoMySqlProRst, err := wrapper.ListRdSforMySqlProxy()
	if err != nil {
		return diag.FromErr(err)
	}

	id, err := uuid.GenerateUUID()
	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(id)

	err = wrapper.listRdSforMySqlProxyToSchema(lisRdSfoMySqlProRst)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

// @API RDS GET /v3/{project_id}/instances/{instance_id}/proxy-list
func (w *MysqlProxiesDSWrapper) ListRdSforMySqlProxy() (*gjson.Result, error) {
	client, err := w.NewClient(w.Config, "rds")
	if err != nil {
		return nil, err
	}

	uri := "/v3/{project_id}/instances/{instance_id}/proxy-list"
	uri = strings.ReplaceAll(uri, "{instance_id}", w.Get("instance_id").(string))
	return httphelper.New(client).
		Method("GET").
		URI(uri).
		Request().
		Result()
}

func (w *MysqlProxiesDSWrapper) listRdSforMySqlProxyToSchema(body *gjson.Result) error {
	d := w.ResourceData
	mErr := multierror.Append(nil,
		d.Set("region", w.Config.GetRegion(w.ResourceData)),
		d.Set("proxy_list", schemas.SliceToList(body.Get("proxy_query_info_list"),
			func(proxyList gjson.Result) any {
				return map[string]any{
					"proxy": schemas.SliceToList(proxyList.Get("proxy"),
						func(proxy gjson.Result) any {
							return map[string]any{
								"id":                                  proxy.Get("pool_id").Value(),
								"name":                                proxy.Get("name").Value(),
								"node_num":                            proxy.Get("node_num").Value(),
								"flavor_info":                         w.setPqilpfi(proxy),
								"proxy_mode":                          proxy.Get("proxy_mode").Value(),
								"subnet_id":                           proxy.Get("subnet_id").Value(),
								"route_mode":                          proxy.Get("route_mode").Value(),
								"status":                              proxy.Get("status").Value(),
								"address":                             proxy.Get("address").Value(),
								"port":                                proxy.Get("port").Value(),
								"delay_threshold_in_seconds":          proxy.Get("delay_threshold_in_seconds").Value(),
								"vcpus":                               proxy.Get("cpu").Value(),
								"memory":                              proxy.Get("mem").Value(),
								"nodes":                               w.setProQueInfLisProNodes(proxy),
								"mode":                                proxy.Get("mode").Value(),
								"transaction_split":                   proxy.Get("transaction_split").Value(),
								"connection_pool_type":                proxy.Get("connection_pool_type").Value(),
								"pay_mode":                            proxy.Get("pay_mode").Value(),
								"dns_name":                            proxy.Get("dns_name").Value(),
								"seconds_level_monitor_fun_status":    proxy.Get("seconds_level_monitor_fun_status").Value(),
								"alt_flag":                            proxy.Get("alt_flag").Value(),
								"force_read_only":                     proxy.Get("force_read_only").Value(),
								"ssl_option":                          proxy.Get("ssl_option").Value(),
								"support_balance_route_mode":          proxy.Get("support_balance_route_mode").Value(),
								"support_proxy_ssl":                   proxy.Get("support_proxy_ssl").Value(),
								"support_switch_connection_pool_type": proxy.Get("support_switch_connection_pool_type").Value(),
								"support_transaction_split":           proxy.Get("support_transaction_split").Value(),
							}
						},
					),
					"master_instance": schemas.SliceToList(proxyList.Get("master_instance"),
						func(masterInstance gjson.Result) any {
							return map[string]any{
								"id":     masterInstance.Get("id").Value(),
								"weight": masterInstance.Get("weight").Value(),
							}
						},
					),
					"readonly_instances": schemas.SliceToList(proxyList.Get("readonly_instances"),
						func(readonlyInstances gjson.Result) any {
							return map[string]any{
								"id":     readonlyInstances.Get("id").Value(),
								"weight": readonlyInstances.Get("weight").Value(),
							}
						},
					),
					"proxy_security_group_check_result": proxyList.Get("proxy_security_group_check_result").Value(),
				}
			},
		)),
		d.Set("max_proxy_num", body.Get("max_proxy_num").Value()),
		d.Set("max_proxy_node_num", body.Get("max_proxy_node_num").Value()),
		d.Set("support_balance_route_mode_for_favored_version", body.Get("support_balance_route_mode_for_favored_version").Value()),
	)
	return mErr.ErrorOrNil()
}

func (*MysqlProxiesDSWrapper) setPqilpfi(proxy gjson.Result) any {
	return schemas.SliceToList(proxy.Get("flavor_info"), func(flavorInfo gjson.Result) any {
		return map[string]any{
			"group_type": flavorInfo.Get("group_type").Value(),
			"code":       flavorInfo.Get("code").Value(),
		}
	})
}

func (*MysqlProxiesDSWrapper) setProQueInfLisProNodes(proxy gjson.Result) any {
	return schemas.SliceToList(proxy.Get("nodes"), func(nodes gjson.Result) any {
		return map[string]any{
			"id":          nodes.Get("id").Value(),
			"status":      nodes.Get("status").Value(),
			"role":        nodes.Get("role").Value(),
			"az_code":     nodes.Get("az_code").Value(),
			"frozen_flag": nodes.Get("frozen_flag").Value(),
		}
	})
}
