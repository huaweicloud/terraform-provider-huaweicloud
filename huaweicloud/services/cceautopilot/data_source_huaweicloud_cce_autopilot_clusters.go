// Generated by PMS #475
package cceautopilot

import (
	"context"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/tidwall/gjson"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/httphelper"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/schemas"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils"
)

func DataSourceCceAutopilotClusters() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceCceAutopilotClustersRead,

		Schema: map[string]*schema.Schema{
			"region": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: `Specifies the region in which to query the resource. If omitted, the provider-level region will be used.`,
			},
			"type": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the master node architecture.`,
			},
			"version": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the version of the cluster.`,
			},
			"status": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the status of the cluster.`,
			},
			"detail": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies whether to get the details of the cluster.`,
			},
			"clusters": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The list of the clusters.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The cluster name.`,
						},
						"alias": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The alias of the cluster.`,
						},
						"annotations": {
							Type:        schema.TypeMap,
							Computed:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: `The cluster annotations in the format of key-value pairs.`,
						},
						"id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The ID of the cluster.`,
						},
						"created_at": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The time when the cluster was created.`,
						},
						"updated_at": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The time when the cluster was updated.`,
						},
						"flavor": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The cluster flavor.`,
						},
						"host_network": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The host network of the cluster.`,
							Elem:        hostNetworkElem(),
						},
						"container_network": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The container network of the cluster.`,
							Elem:        containerNetworkElem(),
						},
						"category": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The cluster type. Only **Turbo** is supported.`,
						},
						"type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The master node architecture.`,
						},
						"description": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The description of the cluster.`,
						},
						"version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The version of the cluster.`,
						},
						"custom_san": {
							Type:        schema.TypeList,
							Computed:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: `The custom SAN field in the API server certificate of the cluster.`,
						},
						"enable_snat": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether SNAT is configured for the cluster.`,
						},
						"enable_swr_image_access": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether the cluster is interconnected with SWR.`,
						},
						"enable_autopilot": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether the cluster is an Autopilot cluster.`,
						},
						"ipv6_enable": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether the cluster uses the IPv6 mode.`,
						},
						"eni_network": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The ENI network of the cluster.`,
							Elem:        eniNetworkElem(),
						},
						"service_network": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The service network of the cluster.`,
							Elem:        serviceNetworkElem(),
						},
						"authentication": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The configurations of the cluster authentication mode.`,
							Elem:        authenticationElem(),
						},
						"tags": {
							Type:        schema.TypeMap,
							Computed:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: `The cluster tags in the format of key-value pairs.`,
						},
						"kube_proxy_mode": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The kube proxy mode of the cluster.`,
						},
						"configurations_override": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The parameter to override the default component configurations in the cluster.`,
							Elem:        configurationsOverrideElem(),
						},
						"extend_param": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The extend param of the cluster.`,
							Elem:        extendParamElem(),
						},
						"az": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The AZ of the cluster.`,
						},
						"platform_version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The cluster platform version.`,
						},
						"status": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The status of the cluster.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"phase": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `The phase of the cluster.`,
									},
									"endpoints": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: `The access address of kube-apiserver in the cluster.`,
										Elem:        clustersStatusEndpointsElem(),
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

// configurationsOverrideElem
// The Elem of "configurations_override"
func configurationsOverrideElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The component name.`,
			},
			"configurations": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The component configuration items.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The component configuration item name.`,
						},
						"value": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The component configuration item value.`,
						},
					},
				},
			},
		},
	}
}

// extendParamElem
// The Elem of "extend_param"
func extendParamElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"enterprise_project_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The ID of the enterprise project to which the cluster belongs.`,
			},
		},
	}
}

// clustersStatusEndpointsElem
// The Elem of "clusters.status.endpoints"
func clustersStatusEndpointsElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"url": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The URL of the endpoint.`,
			},
			"type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The type of the endpoint.`,
			},
		},
	}
}

// hostNetworkElem
// The Elem of "host_network"
func hostNetworkElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"vpc": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The ID of the VPC used to create a master node.`,
			},
			"subnet": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The ID of the subnet used to create a master node.`,
			},
		},
	}
}

// containerNetworkElem
// The Elem of "container_network"
func containerNetworkElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"mode": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The container network type.`,
			},
		},
	}
}

// eniNetworkElem
// The Elem of "eni_network"
func eniNetworkElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"subnets": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The list of ENI subnets.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"subnet_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The IPv4 subnet ID of the subnet used to create control nodes and containers.`,
						},
					},
				},
			},
		},
	}
}

// serviceNetworkElem
// The Elem of "service_network"
func serviceNetworkElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"ipv4_cidr": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The IPv4 CIDR of the service network.`,
			},
		},
	}
}

// authenticationElem
// The Elem of "authentication"
func authenticationElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"mode": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The cluster authentication mode.`,
			},
		},
	}
}

type ClustersDSWrapper struct {
	*schemas.ResourceDataWrapper
	Config *config.Config
}

func newClustersDSWrapper(d *schema.ResourceData, meta interface{}) *ClustersDSWrapper {
	return &ClustersDSWrapper{
		ResourceDataWrapper: schemas.NewSchemaWrapper(d),
		Config:              meta.(*config.Config),
	}
}

func dataSourceCceAutopilotClustersRead(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	wrapper := newClustersDSWrapper(d, meta)
	lisAutCluRst, err := wrapper.ListAutopilotClusters()
	if err != nil {
		return diag.FromErr(err)
	}

	err = wrapper.listAutopilotClustersToSchema(lisAutCluRst)
	if err != nil {
		return diag.FromErr(err)
	}

	id, err := uuid.GenerateUUID()
	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(id)
	return nil
}

// @API CCE GET /autopilot/v3/projects/{project_id}/clusters
func (w *ClustersDSWrapper) ListAutopilotClusters() (*gjson.Result, error) {
	client, err := w.NewClient(w.Config, "cce")
	if err != nil {
		return nil, err
	}

	uri := "/autopilot/v3/projects/{project_id}/clusters"
	params := map[string]any{
		"detail":  w.Get("detail"),
		"status":  w.Get("status"),
		"type":    w.Get("type"),
		"version": w.Get("version"),
	}
	params = utils.RemoveNil(params)
	return httphelper.New(client).
		Method("GET").
		URI(uri).
		Query(params).
		Request().
		Result()
}

func (w *ClustersDSWrapper) listAutopilotClustersToSchema(body *gjson.Result) error {
	d := w.ResourceData
	mErr := multierror.Append(nil,
		d.Set("region", w.Config.GetRegion(w.ResourceData)),
		d.Set("clusters", schemas.SliceToList(body.Get("items"),
			func(clusters gjson.Result) any {
				return map[string]any{
					"name":                    clusters.Get("metadata.name").Value(),
					"alias":                   clusters.Get("metadata.alias").Value(),
					"annotations":             schemas.MapToStrMap(clusters.Get("metadata.annotations")),
					"id":                      clusters.Get("metadata.uid").Value(),
					"created_at":              clusters.Get("metadata.creationTimestamp").Value(),
					"updated_at":              clusters.Get("metadata.updateTimestamp").Value(),
					"flavor":                  clusters.Get("spec.flavor").Value(),
					"host_network":            w.setItemsSpecHostNetwork(clusters),
					"container_network":       w.setIteSpeConNetwork(clusters),
					"category":                clusters.Get("spec.category").Value(),
					"type":                    clusters.Get("spec.type").Value(),
					"description":             clusters.Get("spec.description").Value(),
					"version":                 clusters.Get("spec.version").Value(),
					"custom_san":              schemas.SliceToStrList(clusters.Get("spec.customSan")),
					"enable_snat":             clusters.Get("spec.enableSnat").Value(),
					"enable_swr_image_access": clusters.Get("spec.enableSWRImageAccess").Value(),
					"enable_autopilot":        clusters.Get("spec.enableAutopilot").Value(),
					"ipv6_enable":             clusters.Get("spec.ipv6enable").Value(),
					"eni_network":             w.setItemsSpecEniNetwork(clusters),
					"service_network":         w.setIteSpeSerNetwork(clusters),
					"authentication":          w.setIteSpeAut(clusters),
					"tags":                    w.setItemsSpecClusterTags(clusters),
					"kube_proxy_mode":         clusters.Get("spec.kubeProxyMode").Value(),
					"configurations_override": w.setIteSpeConOverride(clusters),
					"extend_param":            w.setItemsSpecExtendParam(clusters),
					"az":                      clusters.Get("spec.az").Value(),
					"platform_version":        clusters.Get("spec.platformVersion").Value(),
					"status": schemas.SliceToList(clusters.Get("status"),
						func(status gjson.Result) any {
							return map[string]any{
								"phase":     status.Get("phase").Value(),
								"endpoints": w.setItemsStatusEndpoints(status),
							}
						},
					),
				}
			},
		)),
	)
	return mErr.ErrorOrNil()
}

func (*ClustersDSWrapper) setItemsSpecHostNetwork(clusters gjson.Result) any {
	return schemas.SliceToList(clusters.Get("spec.hostNetwork"), func(hostNetwork gjson.Result) any {
		return map[string]any{
			"vpc":    hostNetwork.Get("vpc").Value(),
			"subnet": hostNetwork.Get("subnet").Value(),
		}
	})
}

func (*ClustersDSWrapper) setIteSpeConNetwork(clusters gjson.Result) any {
	return schemas.SliceToList(clusters.Get("spec.containerNetwork"), func(containerNetwork gjson.Result) any {
		return map[string]any{
			"mode": containerNetwork.Get("mode").Value(),
		}
	})
}

func (*ClustersDSWrapper) setItemsSpecEniNetwork(clusters gjson.Result) any {
	return schemas.SliceToList(clusters.Get("spec.eniNetwork"), func(eniNetwork gjson.Result) any {
		return map[string]any{
			"subnets": schemas.SliceToList(eniNetwork.Get("subnets"),
				func(subnets gjson.Result) any {
					return map[string]any{
						"subnet_id": subnets.Get("subnetID").Value(),
					}
				},
			),
		}
	})
}

func (*ClustersDSWrapper) setIteSpeSerNetwork(clusters gjson.Result) any {
	return schemas.SliceToList(clusters.Get("spec.serviceNetwork"), func(serviceNetwork gjson.Result) any {
		return map[string]any{
			"ipv4_cidr": serviceNetwork.Get("IPv4CIDR").Value(),
		}
	})
}

func (*ClustersDSWrapper) setIteSpeAut(clusters gjson.Result) any {
	return schemas.SliceToList(clusters.Get("spec.authentication"), func(authentication gjson.Result) any {
		return map[string]any{
			"mode": authentication.Get("mode").Value(),
		}
	})
}

func (*ClustersDSWrapper) setItemsSpecClusterTags(data gjson.Result) map[string]interface{} {
	tags := data.Get("spec.clusterTags").Value()
	return utils.FlattenTagsToMap(tags)
}

func (*ClustersDSWrapper) setIteSpeConOverride(clusters gjson.Result) any {
	return schemas.SliceToList(clusters.Get("spec.configurationsOverride"), func(conOverride gjson.Result) any {
		return map[string]any{
			"name": conOverride.Get("name").Value(),
			"configurations": schemas.SliceToList(conOverride.Get("configurations"),
				func(configurations gjson.Result) any {
					return map[string]any{
						"name":  configurations.Get("name").Value(),
						"value": configurations.Get("value").Value(),
					}
				},
			),
		}
	})
}

func (*ClustersDSWrapper) setItemsSpecExtendParam(clusters gjson.Result) any {
	return schemas.SliceToList(clusters.Get("spec.extendParam"), func(extendParam gjson.Result) any {
		return map[string]any{
			"enterprise_project_id": extendParam.Get("enterpriseProjectId").Value(),
		}
	})
}

func (*ClustersDSWrapper) setItemsStatusEndpoints(status gjson.Result) any {
	return schemas.SliceToList(status.Get("endpoints"), func(endpoints gjson.Result) any {
		return map[string]any{
			"url":  endpoints.Get("url").Value(),
			"type": endpoints.Get("type").Value(),
		}
	})
}
