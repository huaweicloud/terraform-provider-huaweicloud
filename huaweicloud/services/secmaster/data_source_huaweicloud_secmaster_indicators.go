// Generated by PMS #308
package secmaster

import (
	"context"
	"strings"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/chnsz/golangsdk"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/utils"
)

// @API SecMaster POST /v1/{project_id}/workspaces/{workspace_id}/soc/indicators/search
func DataSourceIndicators() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceIndicatorsRead,

		Schema: map[string]*schema.Schema{
			"region": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: `Specifies the region in which to query the resource. If omitted, the provider-level region will be used.`,
			},
			"workspace_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Specifies the ID of the workspace to which the indicator belongs.`,
			},
			"ids": {
				Type:        schema.TypeList,
				Optional:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `Specifies the indicator IDs.`,
			},
			"data_class_id": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the data class ID.`,
			},
			"from_date": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the search start time.`,
			},
			"to_date": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: `Specifies the search end time.`,
			},
			"condition": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `Specifies the search condition expression.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"conditions": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: `Specifies the condition expression list.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: `Specifies the expression name.`,
									},
									"data": {
										Type:        schema.TypeList,
										Optional:    true,
										Elem:        &schema.Schema{Type: schema.TypeString},
										Description: `Specifies the expression content.`,
									},
								},
							},
						},
						"logics": {
							Type:        schema.TypeList,
							Optional:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: `Specifies the expression logic.`,
						},
					},
				},
			},
			"indicators": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The list of indicators.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The indicator ID.`,
						},
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The indicator name.`,
						},
						"threat_degree": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The threat degree.`,
						},
						"type": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The indicator type.`,
							Elem:        indicatorsTypeElem(),
						},
						"status": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The status.`,
						},
						"confidence": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The confidence. The value range is **80** to **100**.`,
						},
						"first_occurrence_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The first occurred time of the indicator.`,
						},
						"last_occurrence_time": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The last occurred time of the indicator.`,
						},
						"created_at": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The creation time.`,
						},
						"updated_at": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The update time.`,
						},
						"granularity": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `The confidentiality level.`,
						},
						"data_class_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The data class ID.`,
						},
						"value": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The value. Such as **ip**, **url**, **domain** etc.`,
						},
						"data_source": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The data source configuration.`,
							Elem:        indicatorsDataSourceElem(),
						},
						"environment": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `The coordinates of the environment where the indicator was generated.`,
							Elem:        indicatorsEnvironmentElem(),
						},
						"revoked": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether the indicator is discard.`,
						},
						"is_deleted": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Whether the indicator is deleted.`,
						},
						"workspace_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The workspace ID.`,
						},
						"project_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `The project ID.`,
						},
					},
				},
			},
		},
	}
}

func indicatorsDataSourceElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"source_type": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: `The data source type.`,
			},
			"domain_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The domain ID.`,
			},
			"project_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The project ID.`,
			},
			"region_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The region ID.`,
			},
		},
	}
}

func indicatorsTypeElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"indicator_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The indicator type.`,
			},
			"id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Indicator type ID.`,
			},
		},
	}
}

func indicatorsEnvironmentElem() *schema.Resource {
	return &schema.Resource{
		Schema: map[string]*schema.Schema{
			"vendor_type": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The environment provider. Such as **HWCP**, **HWC**, **AWS** or **Azure**.`,
			},
			"domain_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The domain ID.`,
			},
			"project_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The project ID.`,
			},
			"region_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The region ID.`,
			},
		},
	}
}

func dataSourceIndicatorsRead(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	cfg := meta.(*config.Config)
	region := cfg.GetRegion(d)

	var mErr *multierror.Error

	// getIndicators: Query the SecMaster indicators
	var (
		listIndicatorsHttpUrl = "v1/{project_id}/workspaces/{workspace_id}/soc/indicators/search"
		listIndicatorsProduct = "secmaster"
	)
	client, err := cfg.NewServiceClient(listIndicatorsProduct, region)
	if err != nil {
		return diag.Errorf("error creating SecMaster client: %s", err)
	}

	listIndicatorsPath := client.Endpoint + listIndicatorsHttpUrl
	listIndicatorsPath = strings.ReplaceAll(listIndicatorsPath, "{project_id}", client.ProjectID)
	listIndicatorsPath = strings.ReplaceAll(listIndicatorsPath, "{workspace_id}", d.Get("workspace_id").(string))

	listIndicatorsOpt := golangsdk.RequestOpts{
		KeepResponseBody: true,
	}

	param, err := buildIndicatorsBodyParams(d)
	if err != nil {
		return diag.FromErr(err)
	}
	bodyParams := utils.RemoveNil(param)
	indicators := make([]interface{}, 0)
	offset := 0
	for {
		bodyParams["offset"] = offset
		listIndicatorsOpt.JSONBody = bodyParams
		listIndicatorsResp, err := client.Request("POST", listIndicatorsPath, &listIndicatorsOpt)
		if err != nil {
			return diag.FromErr(err)
		}
		listIndicatorsRespBody, err := utils.FlattenResponse(listIndicatorsResp)
		if err != nil {
			return diag.FromErr(err)
		}
		data := utils.PathSearch("data", listIndicatorsRespBody, make([]interface{}, 0)).([]interface{})
		indicators = append(indicators, data...)

		offset += len(data)
		totalCount := utils.PathSearch("total", listIndicatorsRespBody, float64(0))
		if int(totalCount.(float64)) == offset {
			break
		}
	}

	id, err := uuid.GenerateUUID()
	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(id)

	mErr = multierror.Append(
		mErr,
		d.Set("region", region),
		d.Set("indicators", flattenIndicatorsResponseBody(indicators)),
	)

	return diag.FromErr(mErr.ErrorOrNil())
}

func buildIndicatorsBodyParams(d *schema.ResourceData) (map[string]interface{}, error) {
	bodyParams := map[string]interface{}{
		"ids":          utils.ValueIgnoreEmpty(d.Get("ids")),
		"dataclass_id": utils.ValueIgnoreEmpty(d.Get("data_class_id")),
		"limit":        1000,
	}

	if v, ok := d.GetOk("from_date"); ok {
		fromDateWithZ, err := formatInputTime(v.(string))
		if err != nil {
			return nil, err
		}

		bodyParams["from_date"] = fromDateWithZ
	}
	if v, ok := d.GetOk("to_date"); ok {
		toDateWithZ, err := formatInputTime(v.(string))
		if err != nil {
			return nil, err
		}

		bodyParams["to_date"] = toDateWithZ
	}
	if v, ok := d.GetOk("condition.0"); ok {
		bodyParams["condition"] = v
	}

	return bodyParams, nil
}

func flattenIndicatorsResponseBody(resp []interface{}) []interface{} {
	if len(resp) == 0 {
		return nil
	}

	indicators := make([]interface{}, len(resp))
	for i, v := range resp {
		dataObject := utils.PathSearch("data_object", v, nil)
		dataclassRef := utils.PathSearch("dataclass_ref", v, nil)
		indicators[i] = map[string]interface{}{
			"id":                    utils.PathSearch("id", dataObject, nil),
			"name":                  utils.PathSearch("name", dataObject, nil),
			"threat_degree":         utils.PathSearch("verdict", dataObject, nil),
			"type":                  flattenIndicatorsResponseBodyIndicatorType(dataObject),
			"status":                utils.PathSearch("status", dataObject, nil),
			"confidence":            utils.PathSearch("confidence", dataObject, 0),
			"first_occurrence_time": utils.PathSearch("first_report_time", dataObject, nil),
			"last_occurrence_time":  utils.PathSearch("last_report_time", dataObject, nil),
			"created_at":            utils.PathSearch("create_time", dataObject, nil),
			"updated_at":            utils.PathSearch("update_time", dataObject, nil),
			"granularity":           utils.PathSearch("granular_marking", dataObject, 0),
			"data_class_id":         utils.PathSearch("id", dataclassRef, 0),
			"value":                 utils.PathSearch("value", dataObject, nil),
			"data_source":           flattenIndicatorsResponseBodyDataSource(dataObject),
			"environment":           flattenIndicatorsResponseBodyEnvironment(dataObject),
			"revoked":               utils.PathSearch("revoked", dataObject, false),
			"is_deleted":            utils.PathSearch("is_deleted", dataObject, false),
			"workspace_id":          utils.PathSearch("workspace_id", dataObject, nil),
			"project_id":            utils.PathSearch("project_id", dataObject, nil),
		}
	}
	return indicators
}

func flattenIndicatorsResponseBodyIndicatorType(resp interface{}) []interface{} {
	indicatorTypeObj := utils.PathSearch("indicator_type", resp, nil)
	if indicatorTypeObj == nil {
		return nil
	}

	rst := []interface{}{
		map[string]interface{}{
			"id":             utils.PathSearch("id", indicatorTypeObj, nil),
			"indicator_type": utils.PathSearch("indicator_type", indicatorTypeObj, nil),
		},
	}

	return rst
}

func flattenIndicatorsResponseBodyDataSource(resp interface{}) []interface{} {
	dataSourceObj := utils.PathSearch("data_source", resp, nil)
	if dataSourceObj == nil {
		return nil
	}

	rst := []interface{}{
		map[string]interface{}{
			"source_type": utils.PathSearch("source_type", dataSourceObj, 0),
			"domain_id":   utils.PathSearch("domain_id", dataSourceObj, nil),
			"project_id":  utils.PathSearch("project_id", dataSourceObj, nil),
			"region_id":   utils.PathSearch("region_id", dataSourceObj, nil),
		},
	}

	return rst
}

func flattenIndicatorsResponseBodyEnvironment(resp interface{}) []interface{} {
	envObj := utils.PathSearch("environment", resp, nil)
	if envObj == nil {
		return nil
	}

	rst := []interface{}{
		map[string]interface{}{
			"vendor_type": utils.PathSearch("vendor_type", envObj, nil),
			"domain_id":   utils.PathSearch("domain_id", envObj, nil),
			"region_id":   utils.PathSearch("region_id", envObj, nil),
			"project_id":  utils.PathSearch("project_id", envObj, nil),
		},
	}

	return rst
}
