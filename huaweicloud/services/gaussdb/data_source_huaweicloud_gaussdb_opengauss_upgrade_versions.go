// Generated by PMS #530
package gaussdb

import (
	"context"
	"strings"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/tidwall/gjson"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/httphelper"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/helper/schemas"
)

func DataSourceGaussdbOpengaussUpgradeVersions() *schema.Resource {
	return &schema.Resource{
		ReadContext: dataSourceGaussdbOpengaussUpgradeVersionsRead,

		Schema: map[string]*schema.Schema{
			"region": {
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: `Specifies the region in which to query the resource. If omitted, the provider-level region will be used.`,
			},
			"instance_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: `Specifies the ID of the GaussDB OpenGauss instance.`,
			},
			"upgrade_type_list": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Indicates the list of upgrade types.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"upgrade_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Indicates the upgrade type.`,
						},
						"enable": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Indicates whether the upgrade type is available.`,
						},
						"is_parallel_upgrade": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Indicates whether intra-AZ parallel upgrade is supported.`,
						},
						"upgrade_action_list": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Indicates the upgrade actions.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"upgrade_action": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Indicates the upgrade action.`,
									},
									"enable": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: `Indicates whether the upgrade action is available.`,
									},
								},
							},
						},
					},
				},
			},
			"rollback_enabled": {
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `Indicates whether rollback is supported.`,
			},
			"source_version": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Indicates the source instance version.`,
			},
			"target_version": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Indicates the target version.`,
			},
			"roll_upgrade_progress": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Indicates the DN or AZ information during the rolling upgrade.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"upgraded_dn_group_numbers": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Indicates the number of shards that have been upgraded.`,
						},
						"total_dn_group_numbers": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Indicates the total number of shards.`,
						},
						"not_fully_upgraded_az": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Indicates the AZs that have not been upgraded.`,
						},
						"already_upgraded_az": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Indicates the AZs that have upgraded.`,
						},
						"az_description_map": {
							Type:        schema.TypeMap,
							Computed:    true,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: `Indicates the AZ description.`,
						},
					},
				},
			},
			"upgrade_candidate_versions": {
				Type:        schema.TypeList,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `Indicates the versions that can be upgraded to, including minor and major versions.`,
			},
			"hotfix_upgrade_candidate_versions": {
				Type:        schema.TypeList,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `Indicates the hot patch versions that can be updated.`,
			},
			"hotfix_rollback_candidate_versions": {
				Type:        schema.TypeList,
				Computed:    true,
				Elem:        &schema.Schema{Type: schema.TypeString},
				Description: `Indicates the hot patch versions that can be rolled back.`,
			},
			"hotfix_upgrade_infos": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Indicates the information about hot patch versions that can be installed.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Indicates the hot patch version.`,
						},
						"common_patch": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Indicates the patch type.`,
						},
						"backup_sensitive": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Indicates whether the patch is related to backups.`,
						},
						"descripition": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Indicates the description of the patch.`,
						},
					},
				},
			},
			"hotfix_rollback_infos": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `Indicates the information about hot patch versions that can be rolled back.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"version": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Indicates the hot patch version.`,
						},
						"common_patch": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Indicates the patch type.`,
						},
						"backup_sensitive": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: `Indicates whether the patch is related to backups.`,
						},
						"descripition": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: `Indicates the description of the patch.`,
						},
					},
				},
			},
		},
	}
}

type OpengaussUpgradeVersionsDSWrapper struct {
	*schemas.ResourceDataWrapper
	Config *config.Config
}

func newOpengaussUpgradeVersionsDSWrapper(d *schema.ResourceData, meta interface{}) *OpengaussUpgradeVersionsDSWrapper {
	return &OpengaussUpgradeVersionsDSWrapper{
		ResourceDataWrapper: schemas.NewSchemaWrapper(d),
		Config:              meta.(*config.Config),
	}
}

func dataSourceGaussdbOpengaussUpgradeVersionsRead(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	wrapper := newOpengaussUpgradeVersionsDSWrapper(d, meta)
	shoUpgCanVerDetRst, err := wrapper.ShowUpgradeCandidateVersionsDetails()
	if err != nil {
		return diag.FromErr(err)
	}

	id, err := uuid.GenerateUUID()
	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(id)

	err = wrapper.showUpgradeCandidateVersionsDetailsToSchema(shoUpgCanVerDetRst)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

// @API GaussDB GET /v3.1/{project_id}/instances/{instance_id}/db-upgrade/candidate-versions
func (w *OpengaussUpgradeVersionsDSWrapper) ShowUpgradeCandidateVersionsDetails() (*gjson.Result, error) {
	client, err := w.NewClient(w.Config, "opengauss")
	if err != nil {
		return nil, err
	}

	uri := "/v3.1/{project_id}/instances/{instance_id}/db-upgrade/candidate-versions"
	uri = strings.ReplaceAll(uri, "{instance_id}", w.Get("instance_id").(string))
	return httphelper.New(client).
		Method("GET").
		URI(uri).
		Request().
		Result()
}

func (w *OpengaussUpgradeVersionsDSWrapper) showUpgradeCandidateVersionsDetailsToSchema(body *gjson.Result) error {
	d := w.ResourceData
	mErr := multierror.Append(nil,
		d.Set("region", w.Config.GetRegion(w.ResourceData)),
		d.Set("upgrade_type_list", schemas.SliceToList(body.Get("upgrade_type_list"),
			func(upgradeTypeList gjson.Result) any {
				return map[string]any{
					"upgrade_type":        upgradeTypeList.Get("upgrade_type").Value(),
					"enable":              upgradeTypeList.Get("enable").Value(),
					"is_parallel_upgrade": upgradeTypeList.Get("is_parallel_upgrade").Value(),
					"upgrade_action_list": schemas.SliceToList(upgradeTypeList.Get("upgrade_action_list"),
						func(upgradeActionList gjson.Result) any {
							return map[string]any{
								"upgrade_action": upgradeActionList.Get("upgrade_action").Value(),
								"enable":         upgradeActionList.Get("enable").Value(),
							}
						},
					),
				}
			},
		)),
		d.Set("rollback_enabled", body.Get("rollback_enabled").Value()),
		d.Set("source_version", body.Get("source_version").Value()),
		d.Set("target_version", body.Get("target_version").Value()),
		d.Set("roll_upgrade_progress", schemas.ObjectToList(body.Get("roll_upgrade_progress"),
			func(rolUpgProgress gjson.Result) any {
				return map[string]any{
					"upgraded_dn_group_numbers": rolUpgProgress.Get("upgraded_dn_group_numbers").Value(),
					"total_dn_group_numbers":    rolUpgProgress.Get("total_dn_group_numbers").Value(),
					"not_fully_upgraded_az":     rolUpgProgress.Get("not_fully_upgraded_az").Value(),
					"already_upgraded_az":       rolUpgProgress.Get("already_upgraded_az").Value(),
					"az_description_map":        schemas.MapToStrMap(rolUpgProgress.Get("az_description_map")),
				}
			},
		)),
		d.Set("upgrade_candidate_versions", body.Get("upgrade_candidate_versions").Value()),
		d.Set("hotfix_upgrade_candidate_versions", body.Get("hotfix_upgrade_candidate_versions").Value()),
		d.Set("hotfix_rollback_candidate_versions", body.Get("hotfix_rollback_candidate_versions").Value()),
		d.Set("hotfix_upgrade_infos", schemas.SliceToList(body.Get("hotfix_upgrade_infos"),
			func(hotUpgInfos gjson.Result) any {
				return map[string]any{
					"version":          hotUpgInfos.Get("version").Value(),
					"common_patch":     hotUpgInfos.Get("common_patch").Value(),
					"backup_sensitive": hotUpgInfos.Get("backup_sensitive").Value(),
					"descripition":     hotUpgInfos.Get("descripition").Value(),
				}
			},
		)),
		d.Set("hotfix_rollback_infos", schemas.SliceToList(body.Get("hotfix_rollback_infos"),
			func(hotRolInfos gjson.Result) any {
				return map[string]any{
					"version":          hotRolInfos.Get("version").Value(),
					"common_patch":     hotRolInfos.Get("common_patch").Value(),
					"backup_sensitive": hotRolInfos.Get("backup_sensitive").Value(),
					"descripition":     hotRolInfos.Get("descripition").Value(),
				}
			},
		)),
	)
	return mErr.ErrorOrNil()
}
